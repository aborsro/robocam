<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>robocam</title>
<style>
  body { font-family: sans-serif; display: flex; flex-direction: column; padding: 20px; background: linear-gradient(to bottom, #f4f4f4, #e0e0e0); min-height: 100vh; }
  #loginForm, #changeForm { margin-bottom: 20px;}
  
  .form-row {
  display: flex;
  align-items: center;  /* vertically center button with input */
  gap: 15px;            /* increase spacing between input and button */
  margin-bottom: 10px;  /* space below row */
}

.form-row input {
  padding: 6px 10px;
  height: 33px;          /* match button height */
  border-radius: 8px;
  border: 1px solid #ccc;
  font-size: 14px;
}

  #app { display: none; }
  #statusDisplay { margin-top: 10px; font-weight: bold; }
  .top-bar { display: flex; align-items: left; justify-content: left; gap: 10px; flex-wrap: wrap; width: 100%; max-width: 600px; margin-bottom: 10px; }
  .buttons { display: flex; flex-wrap: wrap; gap: 8px; }
  .app-icon { width: 40px; height: 40px; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.2); }
  h1 { margin: 10px; font-size: 1.8em; color: #333; }

  button, select, #toggleSizeBtn {
  font-size: 1.0em;
  margin: 0;
  width: auto;
  max-width: none;
  border: none;
  border-radius: 10px;
  background-color: #808080;
  color: white;
  cursor: pointer;
  transition: background-color 0.3s, transform 0.1s;

/* LED-Kreis innerhalb des Buttons */
button.led {
  display: inline-block;
  width: 10px;
  height: 10px;
  margin-right: 6px;
  border-radius: 50%;
  background-color: grey; /* standard: aus */
  vertical-align: middle;
  box-shadow: 0 0 2px rgba(0,0,0,0.5);
  transition: background-color 0.2s, box-shadow 0.2s;
}

/* LED an, rot */
button.led.on {
  background-color: red;
  box-shadow: 0 0 5px red;
}

  
  /* uniform size */
  height: 33px;
  padding: 0 16px;          /* only horizontal padding */
  
  /* center text vertically */
  display: flex;
  align-items: center;
  justify-content: center;
}


  button:hover:enabled { background-color: #45a049; }
  button:disabled { cursor: not-allowed; opacity: 0.8; }
  button.active { background-color: #00FF00; transform: scale(1.05); }
  #stopBtn { background-color: #FF0000; }
  #stopBtn:hover:enabled { background-color: #d32f2f; }
  #remoteVideo { width: 70%; max-width: 100%; }
  #localVideo { width: 70%; max-width: 100%; }
  #blackoutBtn { background-color: grey; opacity: 1; z-index: 99999; }
  #audioBtn { background-color: grey; opacity: 1; z-index: 99998; }
  #blackoutArea { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: black; opacity: 1; z-index: 99998; }
      #controls {
      margin-bottom: 15px;
    }

    #toggleSizeBtn {
      padding: 10px 20px;
      background: #0077cc;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
    }

    #toggleSizeBtn:hover {
      background: #005fa3;
    }

.video-container {
  position: relative;
  width: 100%;
  max-width: 100%;
  margin: 10px 0;
  display: inline-block; /* keeps video + overlay aligned */
}

video {
  display: block;
  width: 100%;       /* fill width */
  height: auto;
  background: black;
  border: 3px solid #ccc;
  border-radius: 8px;
  position: relative;  /* important: create a new stacking context */
  z-index: 1;          /* video stays below */
}

.status-overlay {
  position: absolute;
  bottom: 10px;
  left: 10px;
  background: rgba(0,0,0,0.6);
  color: #fff;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 14px;
  z-index: 2;           /* overlay on top of video */
  pointer-events: none; /* clicks pass through */
}

.fullwidth {
  max-width: 100% !important;
  width: 100% !important;
  height: 80vh !important;   /* 80% der Fensterhöhe */
  object-fit: contain;       /* Bild komplett anzeigen ohne Verzerrung */
}

  .inline-container img { vertical-align: middle; height: 40px; }
  .inline-container span { vertical-align: middle; margin-left: 10px; font-size: 30px; }

  </style>
</head>
<body>

<!-- Login Form -->
<div id="loginForm">
  <h2>Login for ROBOCAM</h2>
  <div class="form-row">
    <input type="password" id="password" maxlength="20" placeholder="enter password">
    <button onclick="login()">Login</button>
  </div>
  <p id="loginMsg"></p>
</div>

<!-- Change Password Form -->
<div id="changeForm" style="display:none;">
  <h3>Change password (master only)</h3>
  <div class="form-row">
    <input type="password" id="newPassword" maxlength="20" placeholder="new password">
    <button onclick="changePassword()">Change</button>
  </div>
  <p id="changeMsg"></p>
</div>

<!-- robocam App -->
<div id="app">
  <div class="inline-container">
    <img src="favicon.ico" alt="App Icon" class="app-icon">
   <span>robocam</span>v75
   <input type="text" id="infoMsg" style="margin-left: 10px;">
  </div>
  <br>
  <div class="top-bar">
   <div class="buttons">
  	 	<div id="controls">
       <button id="toggleSizeBtn">ðŸ“º wide</button>
    </div>
     <button id="senderBtn" onclick="start('sender')">send</button>
<button id="receiverBtn" onclick="start('receiver')">
  <span class="led"></span> receive
</button>
      <button id="stopBtn" onclick="stopAll()" style="display:none;">stop</button>
      <button id="audioBtn">audio off</button>
      <button id="blackoutBtn" onclick="blackoutScreen()">blackout</button>
      <select id="cameraSelect" style="display:none;"></select>
    </div>
    <div id="blackoutArea"></div>
  </div>
  
  <div class="video-container">
    <video id="remoteVideo" autoplay playsinline></video>
    <div id="remoteStatus" class="status-overlay">Status: idle</div>
  </div>

  <div class="video-container">
    <video id="localVideo" autoplay muted playsinline></video>
    <div id="localStatus" class="status-overlay"></div>
  </div>
</div>

<script>
const localVideo = document.getElementById("localVideo");
const remoteVideo = document.getElementById("remoteVideo");
const toggleBtn = document.getElementById("toggleSizeBtn");
let pc = null;

let role; // "sender" oder "receiver"
let full = false;
let idleRestartTimer = null;
let isNegotiating = false;
let makingOffer = false;
let polite = true; // nur einer der Peers sollte "polite" sein

let stopRequested = false;
let reconnectTimer = null;
let reconnectInProgress = false;
let ws = null;

// Button-Handler für volle Breite
connectWebSocket(); 

// Button-Handler für volle Breite
toggleBtn.onclick = () => {
  full = !full;
  if (full) {
    localVideo.classList.add("fullwidth");
    remoteVideo.classList.add("fullwidth");
    toggleBtn.textContent = "ðŸ”™ normal";
  } else {
    localVideo.classList.remove("fullwidth");
    remoteVideo.classList.remove("fullwidth");
    toggleBtn.textContent = "ðŸ“º wide";
  }
};
	
// --- Login / Passwort-Logik ---
async function login() {
  try {
    const pw = document.getElementById("password").value;
    const res = await fetch("/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ password: pw })
    });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();

    if (data.success) {
      document.getElementById("loginForm").style.display = "none";
      if (data.message === "master") {
         document.getElementById("changeForm").style.display = "block";
      } else {
         document.getElementById("app").style.display = "block";
      }
    } else {
      document.getElementById("loginMsg").innerText = "Wrong Password!";
    }
  } catch (err) {
    console.error("Login-Fehler:", err);
    document.getElementById("loginMsg").innerText = "Serverfehler!";
  }
}

async function changePassword() {
  try {
    const newPw = document.getElementById("newPassword").value;
    const master = document.getElementById("password").value;

    const res = await fetch("/change-password", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ master: master, newPassword: newPw })
    });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();
    document.getElementById("changeMsg").innerText = data.message;
    document.getElementById("loginForm").style.display = "block";
    document.getElementById("changeForm").style.display = "none";
    document.getElementById('password').value = "";
  } catch (err) {
    console.error("Passwort-Änderung Fehler:", err);
    document.getElementById("changeMsg").innerText = "Serverfehler!" + password;
  }
}

// --- robocam Code ---
setInfoMsg("[DEBUG] Initialising ROBOCAM App");

const ConnectionState = {
  IDLE: 'idle', WAITING: 'waiting', READY: 'ready',
  CONNECTING: 'connecting',RECONNECTING: 'try reconnecting', CONNECTED: 'connected', ERROR: 'error',
};
let appState = ConnectionState.IDLE;


function setInfoMsg(msg) {
  console.log(msg);
  const infoMsg = document.getElementById('infoMsg');
  if (infoMsg) infoMsg.value = `${msg}`;
}

function setAppState(state) {
  appState = state;
  setInfoMsg(`[STATE] ${state}`);

  // Show status inside remote video overlay
  const remoteStatus = document.getElementById('remoteStatus');
  if (remoteStatus) remoteStatus.textContent = `Status: ${state}`;

  // optional: also update local overlay if needed
  const localStatus = document.getElementById('localStatus');
  if (localStatus) localStatus.textContent = `Status: ${state}`; 
  
  // --- Auto-restart logic for sender ---
  if (myRole === "sender" && ( state === ConnectionState.IDLE || state === ConnectionState.WAITING)) {
    clearTimeout(idleRestartTimer);
    idleRestartTimer = setTimeout(() => {
      if ((appState === ConnectionState.IDLE)||(appState === ConnectionState.WAITING)) {
        setInfoMsg("[DEBUG] Sender idle/waitung for 5s – restarting...");
        start("sender");
      }
    }, 5000);
  } else {
    clearTimeout(idleRestartTimer);
  }
}

let localStream;
let localOfferSent = false;
let blackOut = false;
let remoteOut = true;
let localOut = true;
let myRole = null;
let audioSetting = true;
let fillCameraSelectDone = false;

const reconnectInterval = 3000;
const ROOM_ID = 'id1';

// Videos aus, werden bei send/receive eingeschaltet
document.getElementById('remoteVideo').style.display = 'none';
document.getElementById('localVideo').style.display = 'none';
document.getElementById("localStatus").style.display = "none";
document.getElementById("remoteStatus").style.display = "none";

function waitForWebSocketOpen(wsInstance, timeout = 5000) {
  return new Promise((resolve, reject) => {
    if (!wsInstance) return reject("WebSocket is null");
    if (wsInstance.readyState === WebSocket.OPEN) return resolve();
    if (wsInstance.readyState === WebSocket.CLOSED) return reject("WebSocket closed");

    const timer = setTimeout(() => {
      reject("WebSocket open timeout");
    }, timeout);

    wsInstance.addEventListener("open", () => {
      clearTimeout(timer);
      resolve();
    }, { once: true });
  });
}

// WebSocket verbinden
function connectWebSocket() {
  if (stopRequested) {
    console.log("[STOP] connectWebSocket aborted");
    return;
  }

  if (ws && ws.readyState <= 1) {
    console.log("[DEBUG] WebSocket already open or connecting");
    return;
  }

  console.log("[DEBUG] Creating new WebSocket");

  const wsProtocol = location.protocol === "https:" ? "wss" : "ws";
  ws = new WebSocket(`${wsProtocol}://${location.host}/ws`);
  
  ws.onopen = () => {
    console.log("[DEBUG] WebSocket opened");
    if (myRole && !stopRequested) {
      ws.send(JSON.stringify({ type: "register", role: myRole, roomId: ROOM_ID }));
    }
  };

  ws.onmessage = async (event) => {
    if (stopRequested) return;
    handleMessage(event);
  };

  ws.onclose = () => {
    if (stopRequested) {
      console.log("[STOP] WebSocket closed — no reconnect");
      return;
    }
    console.log("[DEBUG] WebSocket closed — scheduling reconnect");
    scheduleReconnect();
  };

  ws.onerror = (err) => {
    console.warn("[ERROR] WebSocket error:", err);
    if (!stopRequested) ws.close();
  };
}

// --- ADD scheduleReconnect() FUNCTION ---
function scheduleReconnect() {
  if (stopRequested || reconnectInProgress) {
    console.log("[STOP] scheduleReconnect skipped");
    return;
  }
  reconnectInProgress = true;
  clearTimeout(reconnectTimer);

  reconnectTimer = setTimeout(() => {
    reconnectInProgress = false;
    if (!stopRequested) {
      console.log("[DEBUG] Reconnecting...");
      connectWebSocket();
    } else {
      console.log("[STOP] Reconnect timer expired — stop requested");
    }
  }, reconnectInterval);
}


// --- ICE Server von Xirsys laden ---
async function fetchIceServers() {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          try {
            const res = JSON.parse(xhr.responseText);
            setInfoMsg("Xirsys ICE Servers:", res.v.iceServers);
            resolve(res.v.iceServers);
          } catch (err) { reject(err); }
        } else {
          reject(new Error("Xirsys API Error " + xhr.status));
        }
      }
    };
    xhr.open("PUT", "https://global.xirsys.net/_turn/robocam", true);
    xhr.setRequestHeader("Authorization", "Basic " + btoa("aborsro:e2d37f0c-800f-11f0-98d4-0242ac150002"));
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.send(JSON.stringify({ format: "urls" }));
  });
}


function blackoutScreen() {
  blackOut = !blackOut;
  document.getElementById('blackoutArea').style.display = blackOut ? 'block' : 'none';
  document.getElementById('blackoutBtn').textContent = blackOut ? 'display' : 'blackout';
}

// --- Buttons ---
audioBtn.addEventListener("click", () => {
  audioSetting = !audioSetting;
  setAudioTracks(audioSetting);
  audioBtn.textContent = audioSetting ? "audio off" : "audio on";
});


function setAudioTracks(enable) {
  if (localStream) {
    localStream.getAudioTracks().forEach(track => {
      track.enabled = enable;
    });
  }
}

  
// --- Nachrichten vom Server verarbeiten ---
async function handleMessage(msg) {
  try {
    // --- Blob oder String in Text umwandeln ---
    let text;
    if (msg.data instanceof Blob) {
      text = await msg.data.text();
    } else {
      text = msg.data;
    }

    // --- JSON parsen ---
    let data;
    try {
      data = JSON.parse(text);
    } catch (err) {
      console.error("JSON parse error:", err, text);
      return;
    }
  
    if (data.type === "error") {
      alert(data.message);
      stopAll();
	  return;
    }
	
    // --- Statusmeldungen vom Server ---
    if (data.type === "senderStatus") {
      const senderBtn = document.getElementById("senderBtn");
      window.senderActive = data.active;  // ?? global merken
    
      if (data.active) {
        senderBtn.disabled = true;
        senderBtn.textContent = "sender (locked)";
      } else {
        senderBtn.disabled = false;
        senderBtn.textContent = "send";
      }
      return;
    }


    // --- WebRTC Signalisierung ---
if (data.sdp) {
  if (!pc) return;
  try {
    const description = new RTCSessionDescription(data.sdp);
    const isOffer = description.type === "offer";
    // Offer-Collision erkennen: remote offer + wir machen gerade ein offer ODER signalingState != stable
    const offerCollision = isOffer && (makingOffer || pc.signalingState !== "stable");

    if (offerCollision) {
      if (!polite) {
        // Wenn impolite: ignorieren wir das hereinkommende offer
        setInfoMsg("[DEBUG] Offer collision - ignoring (impolite)");
        return;
      }
      // Wenn polite: rollback des lokalen offers bevor wir remote setzen
      setInfoMsg("[DEBUG] Offer collision - polite peer: rollback local offer");
      try {
        await pc.setLocalDescription({ type: "rollback" });
      } catch (rbErr) {
        console.warn("Rollback failed (might be ok):", rbErr);
      }
    }

    // Wenn es eine Antwort ist: vergewissere dich, dass wir ein local offer hatten
    if (description.type === "answer") {
      if (pc.signalingState !== "have-local-offer") {
        console.warn("Answer ignored – wrong signaling state:", pc.signalingState);
        return;
      }
      await pc.setRemoteDescription(description);
      setInfoMsg("received answer");
      return;
    }

    // Für eingehende Offer (nach evtl. Rollback)
    if (description.type === "offer") {
      await pc.setRemoteDescription(description);
      setInfoMsg("creating answer");
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      ws.send(JSON.stringify({ sdp: pc.localDescription }));
      return;
    }

  } catch (err) {
    console.error("setRemoteDescription error:", err);
  }
  return;
}


    if (data.candidate) {
      if (!pc) return;
      try {
        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
      } catch (err) {
        console.error("addIceCandidate error:", err);
      }
      return;
    }

  } catch (err) {
    console.error("handleMessage error:", err);
  }
}

let playPromise;

function safePlay(videoEl) {
  if (playPromise) {
    playPromise.catch(() => {}).finally(() => {}); // ignore previous play error
  }
  playPromise = videoEl.play();
  playPromise.catch(err => {
    if (err.name !== "AbortError") {
      console.warn("Play error:", err);
    }
  });
}


async function start(role) {
  stopRequested = false;
  reconnectInProgress = false;
  clearTimeout(reconnectTimer);

  // Ensure WebSocket is valid before checking its state
  if (!ws || ws.readyState > 1) {
    console.log("[DEBUG] No active WebSocket, connecting...");
    connectWebSocket();
  }  
  
  document.getElementById("loginForm").style.display = "none";
  document.getElementById("changeForm").style.display = "none";

  setInfoMsg(`[DEBUG] Starte als ${role}`);
  myRole = role;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'register', role: myRole, roomId: ROOM_ID }));
  }
  const senderBtn = document.getElementById('senderBtn');
  const receiverBtn = document.getElementById('receiverBtn');
  const stopBtn = document.getElementById('stopBtn');
  document.getElementById('localVideo').srcObject = null;
  document.getElementById('remoteVideo').srcObject = null;
  senderBtn.disabled = true;
  receiverBtn.disabled = true;
  senderBtn.classList.remove('active');
  receiverBtn.classList.remove('active');
  senderBtn.textContent = "send";
  receiverBtn.textContent = "receive";

  if (role === 'sender') { startSender();   }
                    else { startReceiver(); }
  }
  
  
async function startSender() {

  setInfoMsg("start sender");
  
  await waitForWebSocketOpen(ws); // ? Wait until it's open
  
  ws.send(JSON.stringify({ type: "senderStatus", active: true, roomId: ROOM_ID }));
  ws.send(JSON.stringify({ type: "register", role: "sender", roomId: ROOM_ID }));
  senderBtn.classList.add('active');
  document.getElementById("localVideo").style.display = "block"; 
  document.getElementById("remoteVideo").style.display = "none";
  document.getElementById("remoteStatus").style.display = "none";
  document.getElementById("localStatus").style.display = "block";

  stopBtn.style.display = 'block';
  setAppState(ConnectionState.WAITING);

  // --- ICE Server laden ---
  let iceServers = [];
  try {
    iceServers = await fetchIceServers();
  } catch (e) {
    console.error("ICE Server fetch failed:", e);
  }
  
  pc = new RTCPeerConnection({ iceServers: iceServers.length ? iceServers : [{ urls: "stun:stun.l.google.com:19302" }] });


  
  // --- onnegotiationneeded: create explicit offer ---
  pc.onnegotiationneeded = async () => {
    try {
      makingOffer = true;
      setInfoMsg("[DEBUG] Negotiation needed – creating offer");
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      ws.send(JSON.stringify({ sdp: pc.localDescription }));
    } catch (err) {
      console.error("onnegotiationneeded error:", err);
    } finally {
      makingOffer = false;
    }
  };

  
  // --- Transceiver nur für Sender ---

    setInfoMsg("[DEBUG] Sender: adding sendrecv transceivers");
    pc.addTransceiver("video", { direction: "sendrecv" });
    pc.addTransceiver("audio", { direction: "sendrecv" });


  pc.onconnectionstatechange = () => {
    if (pc.connectionState === "connected") {
      const receivers = pc.getReceivers();
      receivers.forEach(r => {
        if (r.track && r.track.kind === "video") {
          const remoteVideo = document.getElementById("remoteVideo");
          if (remoteVideo.srcObject !== new MediaStream([r.track])) {
            console.log("Rebinding remote video track");
            remoteVideo.srcObject = new MediaStream([r.track]);
          }
        }
      });
    }
  };
 
  pc.onicecandidate = e => { if (e.candidate) ws.send(JSON.stringify({ candidate: e.candidate })); };
  pc.oniceconnectionstatechange = () => {
    setInfoMsg("[DEBUG] ICE state:", pc.iceConnectionState);
    if (['disconnected','failed'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.RECONNECTING); attemptReconnectWithDelay(5);
    }
    if (['connected'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.CONNECTED);
    }
  };


    const select = document.getElementById('cameraSelect');
    select.style.display = 'block';
    await fillCameraSelect();
	await startLocalStream();
    setInfoMsg("sending");
	// select.onchange = () => setAppState(ConnectionState.IDLE);
    // Audio-Button automatisch klicken, wenn Sender startet
    //document.getElementById("audioBtn").click();

}

 async function startReceiver() {

  setInfoMsg("start receiver");
  receiverBtn.classList.add('active'); // optional
  const led = receiverBtn.querySelector('.led');
  if (led) led.classList.add('on');  // LED rot einschalten    document.getElementById("remoteVideo").style.display = "block";
  document.getElementById("localVideo").style.display = "none";
  document.getElementById("remoteVideo").style.display = "block";
  document.getElementById("blackoutArea").style.display = "none";
  document.getElementById("localStatus").style.display = "none";
  document.getElementById("remoteStatus").style.display = "block";
 
  stopBtn.style.display = 'block';
  setAppState(ConnectionState.WAITING);
  
  await waitForWebSocketOpen(ws); // ? Wait until it's open

  
  // --- ICE Server laden ---
  let iceServers = [];
  try {
    iceServers = await fetchIceServers();
  } catch (e) {
    console.error("ICE Server fetch failed:", e);
  }
  
  pc = new RTCPeerConnection({ iceServers: iceServers.length ? iceServers : [{ urls: "stun:stun.l.google.com:19302" }] });

  // --- Transceiver nur für Receiver ---
    setInfoMsg("[DEBUG] Receiver: adding recvonly transceivers");
    pc.addTransceiver("video", { direction: "recvonly" });
    pc.addTransceiver("audio", { direction: "recvonly" });

 
  // --- Remote-Stream empfangen ---
  pc.ontrack = e => {
    setInfoMsg("[DEBUG] track received:", e.streams);
    if (remoteVideo.srcObject !== e.streams[0]) {
      remoteVideo.srcObject = e.streams[0];
    }
    safePlay(remoteVideo);
    setInfoMsg("receiving");
  };
  
  pc.onconnectionstatechange = () => {
    if (pc.connectionState === "connected") {
      const receivers = pc.getReceivers();
      receivers.forEach(r => {
        if (r.track && r.track.kind === "video") {
          const remoteVideo = document.getElementById("remoteVideo");
          if (remoteVideo.srcObject !== new MediaStream([r.track])) {
            console.log("Rebinding remote video track");
            remoteVideo.srcObject = new MediaStream([r.track]);
          }
        }
      });
    }
  };
 
  pc.onicecandidate = e => { if (e.candidate) ws.send(JSON.stringify({ candidate: e.candidate })); };
  pc.oniceconnectionstatechange = () => {
    setInfoMsg("[DEBUG] ICE state:", pc.iceConnectionState);
    if (['disconnected','failed'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.RECONNECTING); attemptReconnectWithDelay(5);
    }
    if (['connected'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.CONNECTED);
    }
  };
}

let getUserMediaDone = false;

// --- unified helper ---
async function getLocalStreamOnce() {
  if (localStream) return localStream; // reuse existing
  setInfoMsg("getLocalStreamOnce: acquiring media...");
  localStream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: audioSetting
  });
  getUserMediaDone = true;
  return localStream;
}

// --- fill camera selector, no camera open here ---
async function fillCameraSelect() {
  try {
    if (!getUserMediaDone) return;
    if (fillCameraSelectDone) return;
    setInfoMsg("fillCameraSelect");

    // Use enumerateDevices() directly — no need to call getUserMedia here
    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoDevices = devices.filter(d => d.kind === "videoinput");
    const select = document.getElementById("cameraSelect");
    select.innerHTML = "";

    videoDevices.forEach((device, i) => {
      const opt = document.createElement("option");
      opt.value = device.deviceId;
      opt.textContent = device.label || `Kamera ${i + 1}`;
      select.appendChild(opt);
    });

    select.onchange = async () => {
      if (!pc) return;
      setInfoMsg("switching camera...");
      await startLocalStreamAndOffer();
    };

    if (lastCameraId) select.value = lastCameraId;
	fillCameraSelectDone = true;
  } catch (err) {
    console.error("fillCameraSelect error:", err);
    alert("Device in use");
    setAppState(ConnectionState.ERROR);
    attemptReconnectWithDelay(5);
  }
}

// --- actual local stream start ---
async function startLocalStream() {
  try {
    setInfoMsg("startLocalStream");

    // one-time stream acquisition
    await getLocalStreamOnce();

    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoDevices = devices.filter(d => d.kind === "videoinput");
    const select = document.getElementById("cameraSelect");

    if (videoDevices.length > 0) select.style.display = "block";

    await startLocalStreamAndOffer();
  } catch (err) {
    console.error("startLocalStream error:", err);
    alert("Device in use");
    setAppState(ConnectionState.ERROR);
    attemptReconnectWithDelay(5);
  }
}


let lastCameraId = null;

async function startLocalStreamAndOffer() {
  try {
    setInfoMsg("startLocalStreamAndOffer");

    const select = document.getElementById('cameraSelect');
    const videoConstraints = select.value ? { deviceId: { exact: select.value } } : true;

    // --- Neuen Stream holen ---
    const newStream = await navigator.mediaDevices.getUserMedia({
      video: videoConstraints,
      audio: audioSetting
    });

    // --- VideoTrack ersetzen oder hinzufügen ---
    if (pc) {
      const videoSender = pc.getSenders().find(s => s.track && s.track.kind === "video");
      const newVideoTrack = newStream.getVideoTracks()[0];

      if (videoSender) {
        await videoSender.replaceTrack(newVideoTrack);
      } else {
        // Kein Sender vorhanden ? Track hinzufügen (löst onnegotiationneeded aus)
        pc.addTrack(newVideoTrack, newStream);
      }

      // --- AudioTrack ersetzen oder hinzufügen ---
      const audioSender = pc.getSenders().find(s => s.track && s.track.kind === "audio");
      const newAudioTrack = newStream.getAudioTracks()[0];
      if (audioSender && newAudioTrack) {
        await audioSender.replaceTrack(newAudioTrack);
      } else if (newAudioTrack) {
        pc.addTrack(newAudioTrack, newStream);
      }
    }

    // --- Lokales Video setzen ---
    localVideo.srcObject = newStream;
    try { await localVideo.play(); } catch (err) { console.warn("localVideo play error:", err); }

    // --- Alten Stream stoppen ---
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
    }
    localStream = newStream;

    setInfoMsg("Camera/Audio updated successfully");
	
// --- nach Kamerawechsel nur Track ersetzen ---
setInfoMsg("Camera/Audio updated successfully");

// Trick: Negotiation anstoßen, wenn nötig
if (pc) {
  setInfoMsg("[DEBUG] Forcing negotiation after camera change");
  pc.dispatchEvent(new Event("negotiationneeded"));
}
	

  } catch (err) {
    console.error("startLocalStreamAndOffer error:", err);
    alert("Cam/Mic access not granted or available");
  }
}


function disableAudio() {
  setInfoMsg("disableAudio");
  audioSetting = false;
  if (localStream) { localStream.getAudioTracks().forEach(t => t.enabled = false); }
  document.getElementById('audioBtn').textContent = 'audio on';
}


function stopAll(showLog = true) {
  if (showLog) setInfoMsg("stopAll - full stop");
  stopRequested = true;
  reconnectInProgress = false;

  clearTimeout(reconnectTimer);
  clearTimeout(idleRestartTimer);

  try {
    if (ws) {
      ws.onclose = null;
      ws.onerror = null;
      ws.onmessage = null;
      ws.close();
    }
  } catch (e) {}
  ws = null;

  try {
    if (pc) pc.close();
  } catch (e) {}
  pc = null;

  try {
    if (localStream) localStream.getTracks().forEach(t => t.stop());
  } catch (e) {}
  localStream = null;

  setAppState(ConnectionState.IDLE);
  setInfoMsg("All connections stopped");

  const senderBtn = document.getElementById('senderBtn');
  const receiverBtn = document.getElementById('receiverBtn');
  senderBtn.disabled = false;
  receiverBtn.disabled = false;
  senderBtn.classList.remove('active');
  const led = receiverBtn.querySelector('.led');
  if (led) led.classList.remove('on');
  document.getElementById('stopBtn').style.display = 'none';
  document.getElementById('cameraSelect').style.display = 'none';
  document.getElementById('blackoutArea').style.display = 'none';

  if (window.senderActive) {
    senderBtn.disabled = true;
    senderBtn.textContent = "sender (locked)";
  }
}


function attemptReconnectWithDelay(seconds) {
  if (stopRequested) {
    setInfoMsg("[DEBUG] attemptReconnectWithDelay skipped (stop requested)");
    return;
  }

  clearTimeout(reconnectTimer);
  reconnectTimer = setTimeout(() => {
    if (stopRequested) {
      setInfoMsg("[DEBUG] reconnect timer cancelled");
      return;
    }
    if (!pc || pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed') {
      setInfoMsg("[DEBUG] try to reconnect after delay");
      stopAll(false); // silent stop
      if (!stopRequested && myRole) start(myRole);
    }
  }, seconds * 1000);
}


// Passwort anzeigen, wenn auf das App-Icon geklickt wird
//document.addEventListener("DOMContentLoaded", () => {
//  const appIcon = document.querySelector(".app-icon");
//  if (appIcon) {
//    appIcon.addEventListener("click", async () => {
//      try {
//        const res = await fetch("/get-master-password");
//        if (!res.ok) throw new Error("Serverfehler");
//        const data = await res.json();
//        alert("Master password: " + data.password);
//      } catch (err) {
//        alert("Fehler beim Abrufen des Passworts: " + err);
//      }
//    });
//  }
//});

</script>
</body>
</html>
