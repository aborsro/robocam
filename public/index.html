<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>robocam</title>
<style>
  body { font-family: sans-serif; display: flex; flex-direction: column; padding: 20px; background: linear-gradient(to bottom, #f4f4f4, #e0e0e0); min-height: 100vh; margin: 0; box-sizing: border-box; }
  #loginForm, #changeForm { margin-bottom: 20px;}
  
  .form-row { display: flex; align-items: center; gap: 15px; margin-bottom: 10px; }
  .form-row input { padding: 6px 10px; height: 33px; border-radius: 8px; border: 1px solid #ccc; font-size: 14px; }

  #audioMeterContainer {
    display: none;
    position: absolute;
    bottom: 40px;
    left: 10px;
    width: 125px;
    height: 6px;
    background: rgba(51, 51, 51, 0.8);
    z-index: 10;
    overflow: hidden;
    border-radius: 3px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    pointer-events: none;
  }

  #audioMeterBar { width: 0%; height: 100%; background-color: #00FF00; box-shadow: 0 0 8px #00FF00; transition: width 0.1s ease-out; }

  #app { display: none; }
  #statusDisplay { margin-top: 10px; font-weight: bold; }
  .top-bar { display: flex; align-items: left; justify-content: left; gap: 10px; flex-wrap: wrap; width: 100%; max-width: 600px; margin-bottom: 10px; }
  .buttons { display: flex; flex-wrap: wrap; gap: 8px; }
  .app-icon { width: 40px; height: 40px; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.2); }
  h1 { margin: 10px; font-size: 1.8em; color: #333; }

  /* BUTTONS */
  button, select, #toggleSizeBtn {
    box-sizing: border-box; font-size: 14px; height: 36px; min-width: 120px; padding: 0 16px;
    display: inline-flex; align-items: center; justify-content: center; gap: 6px;
    border: none; border-radius: 10px; background-color: #808080; color: white; cursor: pointer;
    line-height: 1; white-space: nowrap; transition: background-color 0.3s, transform 0.1s;
  }

  button:hover:enabled { background-color: #45a049; }
  button:disabled { cursor: not-allowed; opacity: 0.7; }
  button.active { background-color: #00FF00; transform: scale(1.05); }
  #stopBtn { background-color: #FF0000; }
  #stopBtn:hover:enabled { background-color: #d32f2f; }

  button .led { display: inline-block; width: 10px; height: 10px; min-width: 10px; border-radius: 50%; background-color: #555; margin-right: 6px; }
  button .led.on { background-color: red; box-shadow: 0 0 6px red; }

  /* Standard Video-Stil (Normal) */
.video-container {
  position: relative;
  width: 100%;
  display: flex;
  justify-content: flex-start; /* Linksbündig im Normalzustand */
  margin: 10px 0;
}

video {
  display: block;
  width: 70%;           /* Deine gewünschte Breite im Normal-Modus */
  max-width: 100%;
  height: auto;
  max-height: 70vh;     /* Begrenzung, damit es nicht zu hoch wird */
  background: black;
  border: 3px solid #ccc;
  border-radius: 8px;
  object-fit: contain;  /* Behält Proportionen bei */
}
  /* Wide-Modus: Maximale Fläche ohne Überlauf */
  .fullwidth {
    width: 100% !important;
    max-width: 100vw !important;
    max-height: 85vh !important; /* Nutzt fast die volle Höhe, lässt Platz für UI */
    border-color: #45a049;      /* Grüner Rahmen zur Bestätigung */
  }
  
  .status-overlay {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.6);
    color: #fff;
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 14px;
    z-index: 2;
    pointer-events: none;
  }

  #blackoutArea {
    display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    width: 100vw; height: 100vh; background-color: #000000 !important;
    z-index: 9999999 !important; touch-action: none;
  }

  .inline-container img { vertical-align: middle; height: 40px; }
  .inline-container span { vertical-align: middle; margin-left: 10px; font-size: 30px; }

  @media (max-width: 480px) {
    button, select, #toggleSizeBtn { min-width: 100px; font-size: 13px; }
    video { width: 100%; } /* Auf kleinen Handys standardmäßig breit */
  }
</style>

</head>
<body>

<div id="loginForm">
  <h2>Login for ROBOCAM</h2>
  <div class="form-row">
    <input type="password" id="password" maxlength="20" placeholder="enter password">
    <button onclick="login()">Login</button>
  </div>
  <p id="loginMsg"></p>
</div>

<div id="changeForm" style="display:none;">
  <h3>Change password (master only)</h3>
  <div class="form-row">
    <input type="password" id="newPassword" maxlength="20" placeholder="new password">
    <button onclick="changePassword()">Change</button>
  </div>
  <p id="changeMsg"></p>
</div>

<div id="app">
  <div class="inline-container">
    <img src="favicon.ico" alt="App Icon" class="app-icon">
   <span>robocam</span>v95
   <input type="text" id="infoMsg" style="margin-left: 10px;">
   <input type="text" id="infoMode" style="margin-left: 10px;">
  </div>
  <br>
  <div class="top-bar">
   <div class="buttons">
  	 	<div id="controls">
       <button id="toggleSizeBtn">ðŸ“º wide</button>
    </div>
     <button id="senderBtn" onclick="start('sender')">send</button>
<button id="receiverBtn" onclick="start('receiver')">
  <span class="led"></span> receive
</button>
      <button id="stopBtn" onclick="stopAll()" style="display:none;">stop</button>
      <button id="audioBtn">audio off</button>
      <button id="blackoutBtn" onclick="blackoutScreen()">blackout</button>
      <select id="cameraSelect" style="display:none;"></select>
    </div>
    <div id="blackoutArea"></div>
  </div>
  
  <div class="video-container">
    <video id="remoteVideo" autoplay playsinline muted></video>
    <audio id="remoteAudio" autoplay playsinline></audio>
      
      <div id="audioMeterContainer">
        <div id="audioMeterBar"></div>
      </div>
      
      <div id="remoteStatus" class="status-overlay">Status: idle</div>
  </div>
  <div class="video-container">
    <video id="localVideo" autoplay muted playsinline></video>
    <div id="localStatus" class="status-overlay"></div>
  </div>
</div>

<script>
const localVideo = document.getElementById("localVideo");
const remoteVideo = document.getElementById("remoteVideo");
const toggleBtn = document.getElementById("toggleSizeBtn");
const meterContainer = document.getElementById("audioMeterContainer");
let pc;
let ws;
let role;

// --- Receiver/Sender Sync ---
let receiverReady = false;
let pendingSenderStart = false;

let full = false;
let idleRestartTimer = null;
let isNegotiating = false;
let makingOffer = false;
let polite = false;
let iceCandidateQueue = []; // ? NEU: Queue für frühe ICE candidates

// --- Integrated Audio Control ---
let audioSetting = true; // For Sender (Mic)
let isAudioMuted = false; // For Receiver (Speaker)
// --- Unified Audio Control ---
function initAudioUI() {
    const audioBtn = document.getElementById("audioBtn");
    if (!audioBtn) return;

    // Set initial UI state
    audioBtn.textContent = "audio on";
    audioBtn.style.backgroundColor = "#45a049";
    
    audioBtn.onclick = () => {
        // We check 'myRole' dynamically at the moment of the click
        if (myRole === 'sender') {
            audioSetting = !audioSetting;
            applySenderAudio();
        } else {
            // Receiver logic: toggle the 'muted' property of the audio element
            isAudioMuted = !isAudioMuted;
            applyReceiverAudio();
        }
    };
}

function applySenderAudio() {
    const btn = document.getElementById('audioBtn');
    if (localStream) {
        localStream.getAudioTracks().forEach(track => track.enabled = audioSetting);
    }
    btn.textContent = audioSetting ? "audio on" : "audio off";
    btn.style.backgroundColor = audioSetting ? "#45a049" : "#808080";
    setInfoMsg(`Mic: ${audioSetting ? 'ON' : 'OFF'}`);
}

function applyReceiverAudio() {
    const btn = document.getElementById('audioBtn');
    const remoteAudio = document.getElementById("remoteAudio");
    
    if (remoteAudio) {
        // Invert: if isAudioMuted is true, element.muted must be true
        remoteAudio.muted = isAudioMuted;
        
        // Browsers often need a fresh .play() call after unmuting
        if (!isAudioMuted) {
            remoteAudio.play().catch(e => console.log("Playback interaction required"));
        }
    }
    
    btn.textContent = !isAudioMuted ? "audio on" : "audio off";
    btn.style.backgroundColor = !isAudioMuted ? "#45a049" : "#808080";
    setInfoMsg(`Speaker: ${!isAudioMuted ? 'ON' : 'OFF'}`);
}

// Call this immediately
initAudioUI();

toggleBtn.onclick = () => {
  full = !full;
  if (full) {
    localVideo.classList.add("fullwidth");
    remoteVideo.classList.add("fullwidth");
    toggleBtn.textContent = "ðŸ”™ normal";
  } else {
    localVideo.classList.remove("fullwidth");
    remoteVideo.classList.remove("fullwidth");
    toggleBtn.textContent = "ðŸ“º wide";
  }
};


// --- Login / Passwort-Logik ---
async function login() {
  try {
    const pw = document.getElementById("password").value;
    const res = await fetch("/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ password: pw })
    });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();

    if (data.success) {
      document.getElementById("loginForm").style.display = "none";
      if (data.message === "master") {
         document.getElementById("changeForm").style.display = "block";
      } else {
         document.getElementById("app").style.display = "block";
      }
    } else {
      document.getElementById("loginMsg").innerText = "Wrong Password!";
    }
  } catch (err) {
    console.error("Login-Fehler:", err);
    document.getElementById("loginMsg").innerText = "Serverfehler!";
  }
}

async function changePassword() {
  try {
    const newPw = document.getElementById("newPassword").value;
    const master = document.getElementById("password").value;

    const res = await fetch("/change-password", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ master: master, newPassword: newPw })
    });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();
    document.getElementById("changeMsg").innerText = data.message;
    document.getElementById("loginForm").style.display = "block";
    document.getElementById("changeForm").style.display = "none";
    document.getElementById('password').value = "";
  } catch (err) {
    console.error("Passwort-Änderung Fehler:", err);
    document.getElementById("changeMsg").innerText = "Serverfehler!";
  }
}

// --- robocam Code ---
setInfoMsg("[DEBUG] Initialising ROBOCAM App");

const ConnectionState = {
  IDLE: 'idle', WAITING: 'waiting', READY: 'ready',
  CONNECTING: 'connecting', CONNECTED: 'connected', NOTCONNECTED: 'not connected',
};
let appState = ConnectionState.IDLE;

function setInfoMsg(msg) {
  console.log(msg);
  const infoMsg = document.getElementById('infoMsg');
  if (infoMsg) infoMsg.value = `${msg}`;
}

function setAppState(state) {
  appState = state;
  setInfoMsg(`[STATE] ${state}`);

  const remoteStatus = document.getElementById('remoteStatus');
  if (remoteStatus) remoteStatus.textContent = `Status: ${state}`;

  const localStatus = document.getElementById('localStatus');
  if (localStatus) localStatus.textContent = `Status: ${state}`; 
}

let localStream;
let localOfferSent = false;
let blackOut = false;
let remoteOut = true;
let localOut = true;
let myRole = null;

let fillCameraSelectDone = false;
let readyInterval = null;

const reconnectInterval = 3000;
const ROOM_ID = 'id1';

document.getElementById('remoteVideo').style.display = 'none';
document.getElementById('localVideo').style.display = 'none';
document.getElementById("localStatus").style.display = "none";
document.getElementById("remoteStatus").style.display = "none";

const iceServers = [
  {
    urls: [
      "stun:fr-turn3.xirsys.com",
      "turn:fr-turn3.xirsys.com:80?transport=udp",
      "turn:fr-turn3.xirsys.com:3478?transport=udp",
      "turn:fr-turn3.xirsys.com:80?transport=tcp",
      "turn:fr-turn3.xirsys.com:3478?transport=tcp",
      "turns:fr-turn3.xirsys.com:443?transport=tcp",
      "turns:fr-turn3.xirsys.com:5349?transport=tcp"
    ],
    username: "h2x8QP2MzZzIqqJdIkTjOPwg2CP9JuX-3ohJnNzzkilRsL5uWXi1bZl56AeLhlfhAAAAAGkPAc1hYm9yc3Jv",
    credential: "77c9ae1a-bc7e-11f0-8996-4a5c3d748004"
  }
];

// ? OPTIMIERT: ICE-Kandidaten-Queue abarbeiten
async function processIceCandidateQueue() {
  if (!pc || !pc.remoteDescription) return;
  
  setInfoMsg(`[DEBUG] Processing ${iceCandidateQueue.length} queued ICE candidates`);
  
  while (iceCandidateQueue.length > 0) {
    const candidate = iceCandidateQueue.shift();
    try {
      await pc.addIceCandidate(new RTCIceCandidate(candidate));
    } catch (err) {
      console.error("Queued candidate error:", err);
    }
  }
}

function createPeerConnection(servers) {
  pc = new RTCPeerConnection({ iceServers: servers });

  pc.oniceconnectionstatechange = () => {
    if (!pc) return;
    setInfoMsg("[DEBUG] ICE state: " + pc.iceConnectionState);
    if (['disconnected','failed'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.NOTCONNECTED);
      attemptReconnectWithDelay(5);
    }
    if (pc.iceConnectionState === 'connected') {
      setAppState(ConnectionState.CONNECTED);
    }
  };

  pc.onicecandidate = e => {
    if (e.candidate && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ candidate: e.candidate }));
    }
  };

  remoteVideo.onplaying = () => {
    // Reveal the meter as soon as video frames are moving
    meterContainer.style.display = "block";
    setInfoMsg("[UI] Stream active - Audio meter visible");
  };

  pc.ontrack = e => {
    if (!e.track) return;
    setInfoMsg(`[DEBUG] Incoming track: ${e.track.kind}`);
 
    if (e.track.kind === "video") {
      if (!remoteVideo.srcObject) {
        remoteVideo.srcObject = new MediaStream();
      }
      remoteVideo.srcObject.addTrack(e.track);
 //     safePlay(remoteVideo);
	  // Explicitly call play to ensure the 'onplaying' event fires
        remoteVideo.play()
            .then(() => {
                setInfoMsg("Video started - showing meter");
                document.getElementById("audioMeterContainer").style.display = "block";
            })
            .catch(err => {
                console.warn("Autoplay blocked, waiting for user interaction:", err);
                setInfoMsg("Click anywhere to start video");
            });
      setInfoMsg("Receiving VIDEO");
    }

    if (e.track.kind === "audio") {
        const audioEl = document.getElementById("remoteAudio");
        audioEl.srcObject = e.streams[0];
        
        // Apply the current mute/unmute toggle state immediately
        applyReceiverAudio(); 
        
        if (typeof attachAudioAnalyzer === "function") {
            attachAudioAnalyzer(e.streams[0]);
        }

       // Autoplay Fix: Browser blockieren Audio oft
       audioEl.play().catch(err => {
         console.warn("Audio autoplay blocked:", err);
         setInfoMsg("AUDIO BLOCKED - Click anywhere to unmute");
         
         // Einmaliger Click-Handler, um Audio zu aktivieren
         const unlockAudio = () => {
           audioEl.play();
           setInfoMsg("Audio unmuted by user");
           window.removeEventListener('click', unlockAudio);
         };
         window.addEventListener('click', unlockAudio);
       });
    }
    setInfoMsg("Receiving AUDIO");
  }
  return pc;
}

function connectWebSocket() {
  const wsProtocol = location.protocol === "https:" ? "wss" : "ws";
  ws = new WebSocket(`${wsProtocol}://${location.host}/ws`);

  ws.onopen = () => {
    setInfoMsg("[DEBUG] WebSocket connected");
    if (myRole)
      ws.send(JSON.stringify({ type: "register", role: myRole, roomId: ROOM_ID }));
    setAppState(ConnectionState.WAITING);
  };

  ws.onmessage = handleMessage;
  ws.onerror = e => console.error("[DEBUG] WebSocket Error:", e);

  ws.onclose = () => {
    console.warn("[DEBUG] WebSocket closed – try reconnect ...");
	setInfoMsg("websocket try reconnect");
    setAppState(ConnectionState.NOTCONNECTED);
    setTimeout(() => {
      connectWebSocket();
      if (myRole) {
        ws.addEventListener("open", () => {
          ws.send(JSON.stringify({ type: "register", role: myRole, roomId: ROOM_ID }));
         }, { once: true });
      }
    }, reconnectInterval);
  };
}

connectWebSocket();

audioSetting = true;
setAudioTracks(audioSetting);

async function blackoutScreen() {
    const area = document.getElementById('blackoutArea');
    const btn = document.getElementById('blackoutBtn');

    if (area.style.display === 'none' || area.style.display === '') {
        // 1. Show the black div (This ALWAYS works on iPhone)
        area.style.display = 'block';
        btn.textContent = 'display';

        // 2. Try to hide the address bar (Works on PC/Android)
        try {
            if (document.documentElement.requestFullscreen) {
                await document.documentElement.requestFullscreen();
            } else if (document.documentElement.webkitRequestFullscreen) {
                // iPhone Safari usually blocks this, but we wrap it in a try/catch
                await document.documentElement.webkitRequestFullscreen();
            }
        } catch (e) {
            console.log("iPhone native fullscreen blocked; using cover mode instead.");
        }
    } else {
        exitBlackout();
    }
}

function exitBlackout() {
    const area = document.getElementById('blackoutArea');
    const btn = document.getElementById('blackoutBtn');
    
    area.style.display = 'none';
    btn.textContent = 'blackout';

    if (document.fullscreenElement || document.webkitFullscreenElement) {
        if (document.exitFullscreen) document.exitFullscreen();
        else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
    }
}

// Crucial for iPhone: Tap the black screen to get back
document.getElementById('blackoutArea').onclick = exitBlackout;

// Handle the "Esc" key on PC
document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) exitBlackout();
});
document.addEventListener('webkitfullscreenchange', () => {
    if (!document.webkitFullscreenElement) exitBlackout();
});

function setAudioTracks(state) {
  audioSetting = state; // Globalen Status setzen
  const btn = document.getElementById('audioBtn');
  
  if (btn) {
    btn.textContent = audioSetting ? "audio on" : "audio off";
    btn.style.backgroundColor = audioSetting ? "#45a049" : "#808080";
  }

  if (localStream) {
    localStream.getAudioTracks().forEach(track => {
      track.enabled = audioSetting;
      console.log(`[AUDIO] Track ${track.label} enabled: ${track.enabled}`);
    });
    setInfoMsg(`Audio tracks (${localStream.getAudioTracks().length}): ${audioSetting ? 'ON' : 'OFF'}`);
  }
}

// ? VERBESSERT: Robustere Message-Behandlung mit ICE-Queue
async function handleMessage(msg) {
  try {
    let text;
    if (msg.data instanceof Blob) {
      text = await msg.data.text();
    } else {
      text = msg.data;
    }

    let data;
    try {
      data = JSON.parse(text);
    } catch (err) {
      console.error("JSON parse error:", err, text);
      return;
    }

    // --- Receiver disconnected / gone ---
    if (data.type === "receiverGone") {
      setInfoMsg("[SYNC] Receiver gone");
      receiverReady = false;
      return;
    }
	
    if (data.type === "receiverReady") {
      setInfoMsg("[SYNC] Got Receiver ready");
    
      receiverReady = true;
    
      if (pendingSenderStart && myRole === 'sender') {
        pendingSenderStart = false;
        startSender();   // ? jetzt wirklich starten
      }
      return;
    }
	
    if (data.type === "error") {
      alert(data.message);
      //stopAll();
      return;
    }

    if (data.type === "senderStatus") {
      const senderBtn = document.getElementById("senderBtn");
      window.senderActive = data.active;

      if (data.active) {
        senderBtn.disabled = true;
        senderBtn.textContent = "sender (locked)";
      } else {
        senderBtn.disabled = false;
        senderBtn.textContent = "send";
      }
      return;
    }

    if (!pc) return;

    // SDP handling
    if (data.sdp) {
      const description = new RTCSessionDescription(data.sdp);
      const isOffer = description.type === "offer";

      // Offer collision
      const offerCollision = isOffer && (makingOffer || pc.signalingState !== "stable");

      if (offerCollision) {
        if (!polite) {
          setInfoMsg("[DEBUG] Offer collision – ignored (impolite peer)");
          return;
        }
        setInfoMsg("[DEBUG] Offer collision – polite peer: rollback local offer");
        try {
          await pc.setLocalDescription({ type: "rollback" });
          makingOffer = false;
        } catch (rbErr) {
          console.warn("Rollback failed (might be ok):", rbErr);
        }
      }

      if (description.type === "answer") {
        if (pc.signalingState === "have-local-offer") {
          await pc.setRemoteDescription(description);
          setInfoMsg("[DEBUG] Answer accepted");
          await processIceCandidateQueue();
        } else {
          console.warn("Answer ignored – wrong signaling state:", pc.signalingState);
        }
        return;
      }

      if (description.type === "offer") {
        try {
          await pc.setRemoteDescription(description);
          await processIceCandidateQueue();
          setInfoMsg("[DEBUG] Creating answer to remote offer");
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({ sdp: pc.localDescription }));
        } catch (err) {
          console.error("Failed to handle remote offer:", err);
        }
        return;
      }
    }

    // ICE candidate handling
    if (data.candidate) {
      if (!pc.remoteDescription || !pc.remoteDescription.type) {
        setInfoMsg("[DEBUG] Queueing ICE candidate (no remote desc yet)");
        iceCandidateQueue.push(data.candidate);
        return;
      }
      try {
        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
      } catch (err) {
        console.error("addIceCandidate error:", err);
      }
    }

  } catch (err) {
    console.error("handleMessage error:", err);
  }
}


let playPromise;

function safePlay(videoEl) {
  if (playPromise) {
    playPromise.catch(() => {}).finally(() => {});
  }
  playPromise = videoEl.play();
  playPromise.catch(err => {
    if (err.name !== "AbortError") {
      console.warn("Play error:", err);
    }
  });
}

async function start(role) {
  document.getElementById("loginForm").style.display = "none";
  document.getElementById("changeForm").style.display = "none";

  setInfoMsg(`[DEBUG] Starte als ${role}`);
  myRole = role;
  polite = (role === 'receiver');
  
  // ? NEU: ICE-Queue zurücksetzen bei neuem Start
  iceCandidateQueue = [];
  
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'register', role: myRole, roomId: ROOM_ID }));
  }
  
  const senderBtn = document.getElementById('senderBtn');
  const receiverBtn = document.getElementById('receiverBtn');
  const stopBtn = document.getElementById('stopBtn');
  
  document.getElementById('localVideo').srcObject = null;
  document.getElementById('remoteVideo').srcObject = null;
  senderBtn.disabled = true;
  receiverBtn.disabled = true;
  senderBtn.classList.remove('active');
  receiverBtn.classList.remove('active');
  senderBtn.textContent = "send";
  receiverBtn.textContent = "receive";

  if (role === 'sender') {
  
    stopBtn.style.display = 'block';   // ? sofort sichtbar
    senderBtn.classList.add('active');
    setAppState(ConnectionState.WAITING);
  
    if (!receiverReady) {
      setInfoMsg("[SYNC] Waiting for receiver...");
      pendingSenderStart = true;
      return;
    }
  
 //   startSender();
  } else { startReceiver(); }  
}
  
function determineConnectionType() {
  pc.addEventListener("iceconnectionstatechange", async () => {
    if (pc.iceConnectionState === "connected") {
      try {
        const stats = await pc.getStats();
        stats.forEach(report => {
          if (report.type === "candidate-pair" && report.state === "succeeded") {
            const local = stats.get(report.localCandidateId);
            const remote = stats.get(report.remoteCandidateId);
  
            if (local && remote) {
              let connectionType = "Unknown connection";
  
              if (local.candidateType === "relay" || remote.candidateType === "relay") {
                connectionType = "TURN connection active";
                console.log("? TURN server in use (relay)");
              } else if (local.candidateType === "srflx" || remote.candidateType === "srflx") {
                connectionType = "STUN connection active";
                console.log("? STUN server in use (srflx)");
              } else if (local.candidateType === "host" || remote.candidateType === "host") {
                connectionType = "Direct P2P connection";
                console.log("? Direct peer-to-peer (host)");
              }
  
              const infoField = document.getElementById("infoMode");
              if (infoField) infoField.value = connectionType;
            }
          }
        });
      } catch (err) {
        console.error("Error checking ICE candidates:", err);
      }
    }
  });
}

async function startSender() {
  setInfoMsg("start sender");
  ws.send(JSON.stringify({ type: "senderStatus", active: true, roomId: ROOM_ID }));
  ws.send(JSON.stringify({ type: "register", role: "sender", roomId: ROOM_ID }));
  senderBtn.classList.add('active');
  document.getElementById("localVideo").style.display = "block"; 
  document.getElementById("remoteVideo").style.display = "none";
  document.getElementById("remoteStatus").style.display = "none";
  document.getElementById("localStatus").style.display = "block";

  stopBtn.style.display = 'block';
  setAppState(ConnectionState.WAITING);

  pc = createPeerConnection(iceServers); 
  determineConnectionType();

  pc.onnegotiationneeded = async () => {
    try {
      makingOffer = true;
      setInfoMsg("[DEBUG] Negotiation needed – creating offer");
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      ws.send(JSON.stringify({ sdp: pc.localDescription }));
    } catch (err) {
      console.error("onnegotiationneeded error:", err);
    } finally {
      makingOffer = false;
    }
  };

  pc.onconnectionstatechange = () => {
    if (!pc) return;
    if (pc.connectionState === "connected") {
      const receivers = pc.getReceivers();
      receivers.forEach(r => {
        if (r.track && r.track.kind === "video") {
          const remoteVideo = document.getElementById("remoteVideo");
          if (remoteVideo.srcObject !== new MediaStream([r.track])) {
            console.log("Rebinding remote video track");
            remoteVideo.srcObject = new MediaStream([r.track]);
          }
        }
      });
    }
  };
 
  pc.onicecandidate = e => { 
    if (e.candidate) ws.send(JSON.stringify({ candidate: e.candidate })); 
  };
  
  pc.oniceconnectionstatechange = () => {
    if (!pc) return;
    setInfoMsg("[DEBUG] ICE state:", pc.iceConnectionState);
    if (['disconnected','failed'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.NOTCONNECTED); 
      attemptReconnectWithDelay(5);
    }
    if (['connected'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.CONNECTED);
    }
  };

  // ? WICHTIG: Erst Local Stream starten, DANN Tracks hinzufügen
  const select = document.getElementById('cameraSelect');
  select.style.display = 'block';
  await startLocalStream();
  await fillCameraSelect();

  select.onchange = async () => {
    await startLocalStreamAndOffer();
  };
}

async function startReceiver() {
  setInfoMsg("start receiver");

  receiverBtn.classList.add('active');
  const led = receiverBtn.querySelector('.led');
  if (led) led.classList.add('on');
    
  document.getElementById("remoteVideo").style.display = "block";
  document.getElementById("localVideo").style.display = "none";
  document.getElementById("blackoutArea").style.display = "none";
  document.getElementById("localStatus").style.display = "none";
  document.getElementById("remoteStatus").style.display = "block";
 
  stopBtn.style.display = 'block';
  setAppState(ConnectionState.WAITING);

  pc = createPeerConnection(iceServers); 
  determineConnectionType();

  // ensure no old interval is running
  if (readyInterval) {
    clearInterval(readyInterval);
    readyInterval = null;
  }

  // Dann Transceiver hinzufügen
  setInfoMsg("[DEBUG] Receiver: adding recvonly transceivers");
  pc.addTransceiver("video", { direction: "recvonly" });
  pc.addTransceiver("audio", { direction: "recvonly" });

  function sendReceiverReady() {
    setInfoMsg("[SYNC] sending receiverReady");
    ws.send(JSON.stringify({ type: "receiverReady", roomId: ROOM_ID }));
  }
  
  if (ws.readyState === WebSocket.OPEN) {
    sendReceiverReady();
  } else {
    ws.addEventListener("open", sendReceiverReady, { once: true });
  }
  
  pc.onconnectionstatechange = () => {
    if (!pc) return;
    if (pc.connectionState === "connected") {
      const receivers = pc.getReceivers();
      receivers.forEach(r => {
        if (r.track && r.track.kind === "video") {
          const remoteVideo = document.getElementById("remoteVideo");
          if (remoteVideo.srcObject !== new MediaStream([r.track])) {
            console.log("Rebinding remote video track");
            remoteVideo.srcObject = new MediaStream([r.track]);
          }
        }
      });
    }
  };
 
  pc.onicecandidate = e => { if (e.candidate) ws.send(JSON.stringify({ candidate: e.candidate })); };
  pc.oniceconnectionstatechange = () => {
    setInfoMsg("[DEBUG] ICE state:", pc.iceConnectionState);
    if (['disconnected','failed'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.NOTCONNECTED); 
      attemptReconnectWithDelay(5);
    }
    if (['connected'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.CONNECTED);
	  if (readyInterval) {
         clearInterval(readyInterval);
         readyInterval = null;
      }
    }
  };
  console.log("### startReceiver END reached ###");

  setInfoMsg("[SYNC] sending receiverReady");
  ws.send(JSON.stringify({
    type: "receiverReady",
    roomId: ROOM_ID
  }));
  

  readyInterval = setInterval(() => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: "receiverReady",
        roomId: ROOM_ID
      }));
      setInfoMsg("[SYNC] resend receiverReady");
    }
  }, 1000);
  
  // Am Ende von startReceiver() einfügen:
  const remoteAudio = document.getElementById("remoteAudio");
  if (remoteAudio) {
    remoteAudio.muted = isAudioMuted; // Übernimmt den aktuellen Button-Status
  }
}

async function getLocalStreamOnce() {
  if (localStream) return localStream;
  setInfoMsg("getLocalStreamOnce: acquiring media...");
  localStream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: true
  });
  return localStream;
}

async function fillCameraSelect() {
  try {
    if (fillCameraSelectDone) return;
    setInfoMsg("fillCameraSelect");

    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoDevices = devices.filter(d => d.kind === "videoinput");
    const select = document.getElementById("cameraSelect");
    select.innerHTML = "";

    videoDevices.forEach((device, i) => {
      const opt = document.createElement("option");
      opt.value = device.deviceId;
      opt.textContent = device.label || `Kamera ${i + 1}`;
      select.appendChild(opt);
    });

    select.onchange = async () => {
      if (!pc) return;
      setInfoMsg("switching camera...");
      await startLocalStreamAndOffer();
    };

    if (lastCameraId) select.value = lastCameraId;
    fillCameraSelectDone = true;
  } catch (err) {
    console.error("fillCameraSelect error:", err);
    alert("Device in use");
    setAppState(ConnectionState.NOTCONNECTED);
    attemptReconnectWithDelay(5);
  }
}

async function startLocalStream() {
  try {
    setInfoMsg("startLocalStream");
    await getLocalStreamOnce();

    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoDevices = devices.filter(d => d.kind === "videoinput");
    const select = document.getElementById("cameraSelect");

    if (videoDevices.length > 0) select.style.display = "block";

    await startLocalStreamAndOffer();
  } catch (err) {
    console.error("startLocalStream error:", err);
    alert("Device in use");
    setAppState(ConnectionState.NOTCONNECTED);
    attemptReconnectWithDelay(5);
  }
}

let lastCameraId = null;

// ? KRITISCH: startLocalStreamAndOffer muss Tracks zur PeerConnection hinzufügen
async function startLocalStreamAndOffer() {
  try {
    setInfoMsg("startLocalStreamAndOffer");

    const select = document.getElementById('cameraSelect');
    const videoConstraints = select.value ? { deviceId: { exact: select.value } } : true;

    // Prüfen ob bereits die gleiche Kamera aktiv ist
    if (localStream && localStream.active) {
      const currentVideoTrack = localStream.getVideoTracks()[0];
      if (currentVideoTrack && currentVideoTrack.getSettings().deviceId === select.value) {
        setInfoMsg("Same camera already active");
//        return;
      }
    }

    const newStream = await navigator.mediaDevices.getUserMedia({
      video: videoConstraints,
      audio: true
    });

    const newVideoTrack = newStream.getVideoTracks()[0];
    const newAudioTrack = newStream.getAudioTracks()[0];

    if (pc) {
      const senders = pc.getSenders();
      const videoSender = senders.find(s => s.track?.kind === "video");
      const audioSender = senders.find(s => s.track?.kind === "audio");

      // ? WICHTIG: Beim ersten Mal addTrack, danach replaceTrack
      if (videoSender) {
        setInfoMsg("[DEBUG] Replacing video track");
        await videoSender.replaceTrack(newVideoTrack);
      } else if (newVideoTrack) {
        setInfoMsg("[DEBUG] Adding video track to PeerConnection");
        pc.addTrack(newVideoTrack, newStream);
      }

      if (audioSender) {
        setInfoMsg("[DEBUG] Replacing audio track");
        await audioSender.replaceTrack(newAudioTrack);
      } else if (newAudioTrack) {
        setInfoMsg("[DEBUG] Adding audio track to PeerConnection");
        pc.addTrack(newAudioTrack, newStream);
      }
    }

    // Lokales Video aktualisieren
    localVideo.srcObject = newStream;
    try { 
      await localVideo.play(); 
    } catch (err) { 
      console.warn("localVideo play error:", err); 
    }

    // Alten Stream stoppen
    if (localStream && localStream !== newStream) {
      localStream.getTracks().forEach(track => track.stop());
    }
    
    localStream = newStream;
    lastCameraId = select.value;

    setInfoMsg("Camera/Audio updated - tracks added to PC");

  } catch (err) {
    console.error("startLocalStreamAndOffer error:", err);
    alert("Cam/Mic access not granted or available");
  }
  
  // Apply current audio button state to new stream
  if (localStream) {
    localStream.getAudioTracks().forEach(t => {
      t.enabled = audioSetting;
    });
  }
}



function applyAudioStatus() {
    const audioBtn = document.getElementById("audioBtn");
    const remoteAudio = document.getElementById("remoteAudio");
    const remoteVideo = document.getElementById("remoteVideo");
    const bar = document.getElementById('audioMeterBar');

    // 1. UI aktualisieren
    if (isAudioMuted) {
        audioBtn.textContent = "audio off";
        audioBtn.style.setProperty("background-color", "#808080", "important");
        if (bar) bar.style.backgroundColor = "#ff4444";
    } else {
        audioBtn.textContent = "audio on";
        audioBtn.style.setProperty("background-color", "#45a049", "important");
        if (bar) bar.style.backgroundColor = "#00FF00";
    }

    // 2. Aktion: BEIDE Elemente (Video & Audio) stummschalten
    // Manchmal kommt der Ton über das Video-Element mit!
    [remoteAudio, remoteVideo].forEach(el => {
        if (el) {
            el.muted = isAudioMuted;
            // Falls unmuted, sicherheitshalber play() aufrufen
            if (!isAudioMuted) el.play().catch(() => {});
        }
    });

    setInfoMsg("Audio is now: " + (isAudioMuted ? "OFF" : "ON"));
}


function toggleAudio() {
    isAudioMuted = !isAudioMuted;
    applyAudioStatus();
}


// ? OPTIMIERT: Memory Leak Fix - alle Ressourcen sauber freigeben
function stopAll() {
  setInfoMsg("stopAll");
  setAppState(ConnectionState.IDLE);
  localOfferSent = false;
  receiverReady = false;
  pendingSenderStart = false;

  // ? NEU: Video-Elemente sauber leeren
  const localVideoEl = document.getElementById('localVideo');
  const remoteVideoEl = document.getElementById('remoteVideo');
  const infoField = document.getElementById("infoMode");
  infoField.value = "";
 
 // Audio-Balken zurücksetzen
  const bar = document.getElementById('audioMeterBar');
  if (bar) bar.style.width = "0%";
  setInfoMsg("Stopped and Meter reset");
 
  if (readyInterval) {
    clearInterval(readyInterval);
    readyInterval = null;
  }
 
  if (localVideoEl) {
    localVideoEl.pause();
    localVideoEl.srcObject = null;
  }
  
  if (remoteVideoEl) {
    remoteVideoEl.pause();
    remoteVideoEl.srcObject = null;
  }
  
  if (myRole === "sender") {
    ws.send(JSON.stringify({ type: "senderStatus", active: false, roomId: ROOM_ID }));
  }

  // ? OPTIMIERT: PeerConnection mit allen Tracks stoppen
  if (pc) {
    pc.getSenders().forEach(sender => {
      if (sender.track) sender.track.stop();
    });
    
    pc.oniceconnectionstatechange = null;
    pc.onconnectionstatechange = null;
    pc.onnegotiationneeded = null;
    pc.onicecandidate = null;
    pc.ontrack = null;
    pc.close();
    pc = null;
  }
  
  // ? OPTIMIERT: LocalStream vollständig stoppen
  if (localStream) {
    localStream.getTracks().forEach(t => {
      t.stop();
      t.enabled = false;
    });
    localStream = null;
  }
  
  // ? NEU: ICE-Queue zurücksetzen
  iceCandidateQueue = [];
  
  const senderBtn = document.getElementById('senderBtn');
  const receiverBtn = document.getElementById('receiverBtn');

  senderBtn.disabled = false;
  receiverBtn.disabled = false;
  senderBtn.classList.remove('active');
  receiverBtn.classList.remove('active');
  
  const led = receiverBtn.querySelector('.led');
  if (led) led.classList.remove('on');
  
  document.getElementById('stopBtn').style.display = 'none';
  document.getElementById('cameraSelect').style.display = 'none';
  document.getElementById('blackoutArea').style.display = 'none';

  if (window.senderActive) {
    senderBtn.disabled = true;
    senderBtn.textContent = "sender (locked)";
  }
}

function attemptReconnectWithDelay(seconds) {
  setInfoMsg("try reconnect");
  setTimeout(() => {
    if (!pc || pc.iceConnectionState === 'disconnected') {
      setInfoMsg("[DEBUG] try to reconnect");
      stopAll(); 
      if (myRole) start(myRole);
    }
  }, seconds * 1000);
}


function attachAudioAnalyzer(stream) {
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioContext.createMediaStreamSource(stream);
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 256;
    source.connect(analyser);

    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    const bar = document.getElementById('audioMeterBar');
    if (bar) {
      // Setzt die Farbe sofort beim Start des Empfangs passend zum Button-Status
      bar.style.backgroundColor = isAudioMuted ? "#ff4444" : "#00FF00";
    }
    function updateMeter() {
      // Prüfen, ob der Stream oder Tracks gestoppt wurden
      const isStreamActive = stream.active && stream.getAudioTracks().some(t => t.readyState === 'live');
      
      if (!bar) return;

      if (!isStreamActive) {
        bar.style.width = "0%";
        // Beende die Animation, wenn der Stream tot ist
        if (audioContext.state !== 'closed') audioContext.close();
        return; 
      }

      analyser.getByteFrequencyData(dataArray);
      let sum = 0;
      for (let i = 0; i < bufferLength; i++) {
        sum += dataArray[i];
      }
      let average = sum / bufferLength;
      
      // Balken aktualisieren (Sensibilität: average * 2)
      bar.style.width = Math.min(100, (average * 2.5)) + "%";
      requestAnimationFrame(updateMeter);
    }
    updateMeter();
  } catch (e) {
    console.warn("Audio Analyzer Error:", e);
  }
  document.getElementById("audioBtn").onclick = toggleAudio;
}
</script>
</body>
</html>