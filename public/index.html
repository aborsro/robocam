<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>robocam</title>
<style>
  body { font-family: sans-serif; display: flex; flex-direction: column; padding: 20px; background: linear-gradient(to bottom, #f4f4f4, #e0e0e0); min-height: 100vh; }
  #loginForm, #changeForm { margin-bottom: 20px;}
  
  .form-row {
  display: flex;
  align-items: center;  /* vertically center button with input */
  gap: 15px;            /* increase spacing between input and button */
  margin-bottom: 10px;  /* space below row */
}

.form-row input {
  padding: 6px 10px;
  height: 33px;          /* match button height */
  border-radius: 8px;
  border: 1px solid #ccc;
  font-size: 14px;
}

  #app { display: none; }
  #statusDisplay { margin-top: 10px; font-weight: bold; }
  .top-bar { display: flex; align-items: left; justify-content: left; gap: 10px; flex-wrap: wrap; width: 100%; max-width: 600px; margin-bottom: 10px; }
  .buttons { display: flex; flex-wrap: wrap; gap: 8px; }
  .app-icon { width: 40px; height: 40px; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.2); }
  h1 { margin: 10px; font-size: 1.8em; color: #333; }

  button, select, #toggleSizeBtn {
  font-size: 1.0em;
  margin: 0;
  width: auto;
  max-width: none;
  border: none;
  border-radius: 10px;
  background-color: #808080;
  color: white;
  cursor: pointer;
  transition: background-color 0.3s, transform 0.1s;

  /* uniform size */
  height: 33px;
  padding: 0 16px;          /* only horizontal padding */
  
  /* center text vertically */
  display: flex;
  align-items: center;
  justify-content: center;
}


  button:hover:enabled { background-color: #45a049; }
  button:disabled { cursor: not-allowed; opacity: 0.8; }
  button.active { background-color: #00FF00; transform: scale(1.05); }
  #stopBtn { background-color: #FF0000; }
  #stopBtn:hover:enabled { background-color: #d32f2f; }
  #remoteVideo { width: 80%; max-width: 100%; }
  #localVideo { width: 80%; max-width: 100%; }
  #blackoutBtn { background-color: grey; opacity: 1; z-index: 99999; }
  #audioBtn { background-color: grey; opacity: 1; z-index: 99998; }
  #blackoutArea { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: black; opacity: 1; z-index: 99998; }
      #controls {
      margin-bottom: 15px;
    }

    #toggleSizeBtn {
      padding: 10px 20px;
      background: #0077cc;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
    }

    #toggleSizeBtn:hover {
      background: #005fa3;
    }

.video-container {
  position: relative;
  width: 100%;
  max-width: 100%;
  margin: 10px 0;
  display: inline-block; /* keeps video + overlay aligned */
}

video {
  display: block;
  width: 100%;       /* fill width */
  height: auto;
  background: black;
  border: 3px solid #ccc;
  border-radius: 8px;
  position: relative;  /* important: create a new stacking context */
  z-index: 1;          /* video stays below */
}

.status-overlay {
  position: absolute;
  bottom: 10px;
  left: 10px;
  background: rgba(0,0,0,0.6);
  color: #fff;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 14px;
  z-index: 2;           /* overlay on top of video */
  pointer-events: none; /* clicks pass through */
}

    .fullwidth {
      max-width: 100% !important;
      width: 100% !important;
      height: auto !important;
    }
  .inline-container img { vertical-align: middle; height: 40px; }
  .inline-container span { vertical-align: middle; margin-left: 10px; font-size: 40px; }

  </style>
</head>
<body>

<!-- Login Form -->
<div id="loginForm">
  <h2>Login for ROBOCAM</h2>
  <div class="form-row">
    <input type="password" id="password" maxlength="20" placeholder="enter password">
    <button onclick="login()">Login</button>
  </div>
  <p id="loginMsg"></p>
</div>

<!-- Change Password Form -->
<div id="changeForm" style="display:none;">
  <h3>Change password (master only)</h3>
  <div class="form-row">
    <input type="password" id="newPassword" maxlength="20" placeholder="new password">
    <button onclick="changePassword()">Change</button>
  </div>
  <p id="changeMsg"></p>
</div>

<!-- robocam App -->
<div id="app">
  <div class="inline-container">
    <img src="favicon.ico" alt="App Icon" class="app-icon">
   <span>robocam</span>v26
   <input type="text" id="infoMsg" style="margin-left: 10px;">
  </div>
  <br>
  <div class="top-bar">
   <div class="buttons">
  	 	<div id="controls">
       <button id="toggleSizeBtn">ðŸ“º wide</button>
    </div>
     <button id="senderBtn" onclick="start('sender')">send</button>
      <button id="receiverBtn" onclick="start('receiver')">receive</button>
      <button id="stopBtn" onclick="stopAll()" style="display:none;">stop</button>
      <button id="audioBtn" onclick="toggleAudio()">audio on</button>
      <button id="blackoutBtn" onclick="blackoutScreen()">blackout</button>
      <select id="cameraSelect" style="display:none;"></select>
    </div>
    <div id="blackoutArea"></div>
  </div>
  
  <div class="video-container">
    <video id="remoteVideo" autoplay playsinline></video>
    <div id="remoteStatus" class="status-overlay">Status: idle</div>
  </div>

  <div class="video-container">
    <video id="localVideo" autoplay muted playsinline></video>
    <div id="localStatus" class="status-overlay"></div>
  </div>
</div>

<script>
const localVideo = document.getElementById("localVideo");
const remoteVideo = document.getElementById("remoteVideo");
const toggleBtn = document.getElementById("toggleSizeBtn");
let pc;
let ws;
let role; // "sender" oder "receiver"
let full = false;
let idleRestartTimer = null;

    // Button-Handler für volle Breite
    toggleBtn.onclick = () => {
      full = !full;
      if (full) {
        localVideo.classList.add("fullwidth");
        remoteVideo.classList.add("fullwidth");
        toggleBtn.textContent = "ðŸ”™ normal";
      } else {
        localVideo.classList.remove("fullwidth");
        remoteVideo.classList.remove("fullwidth");
        toggleBtn.textContent = "ðŸ“º wide";
      }
    };
	
// --- Login / Passwort-Logik ---
async function login() {
  try {
    const pw = document.getElementById("password").value;
    const res = await fetch("/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ password: pw })
    });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();

    if (data.success) {
      document.getElementById("loginForm").style.display = "none";
      if (data.message === "master") {
         document.getElementById("changeForm").style.display = "block";
      } else {
         document.getElementById("app").style.display = "block";
      }
    } else {
      document.getElementById("loginMsg").innerText = "Wrong Password!";
    }
  } catch (err) {
    console.error("Login-Fehler:", err);
    document.getElementById("loginMsg").innerText = "Serverfehler!";
  }
}

async function changePassword() {
  try {
    const newPw = document.getElementById("newPassword").value;
    const master = document.getElementById("password").value;

    const res = await fetch("/change-password", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ master: master, newPassword: newPw })
    });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();
    document.getElementById("changeMsg").innerText = data.message;
    document.getElementById("loginForm").style.display = "block";
    document.getElementById("changeForm").style.display = "none";
    document.getElementById('password').value = "";
  } catch (err) {
    console.error("Passwort-Änderung Fehler:", err);
    document.getElementById("changeMsg").innerText = "Serverfehler!" + password;
  }
}

// --- robocam Code ---
console.log("[DEBUG] Initialising ROBOCAM App");

const ConnectionState = {
  IDLE: 'idle', WAITING: 'waiting', READY: 'ready',
  CONNECTING: 'connecting', CONNECTED: 'connected', ERROR: 'error',
};
let appState = ConnectionState.IDLE;


function setInfoMsg(msg) {
  const infoMsg = document.getElementById('infoMsg');
  if (infoMsg) infoMsg.value = `${msg}`;
}

function setAppState(state) {
  appState = state;
  console.log(`[STATE] ${state}`);
//  document.getElementById('statusDisplay').textContent = `Status: ${state}`;

  // Show status inside remote video overlay
  const remoteStatus = document.getElementById('remoteStatus');
  if (remoteStatus) remoteStatus.textContent = `Status: ${state}`;

  // optional: also update local overlay if needed
  const localStatus = document.getElementById('localStatus');
  if (localStatus) localStatus.textContent = `Status: ${state}`; 
  
  // --- Auto-restart logic for sender ---
  if (myRole === "sender" && ( state === ConnectionState.IDLE || state === ConnectionState.WAITING)) {
    clearTimeout(idleRestartTimer);
    idleRestartTimer = setTimeout(() => {
      if ((appState === ConnectionState.IDLE)||(appState === ConnectionState.WAITING)) {
        console.log("[DEBUG] Sender idle/waitung for 5s – restarting...");
        start("sender");
      }
    }, 5000);
  } else {
    clearTimeout(idleRestartTimer);
  }
}

let localStream;
let localOfferSent = false;
let blackOut = false;
let remoteOut = true;
let localOut = true;
let myRole = null;
let audioSetting = true;

const reconnectInterval = 3000;
const ROOM_ID = 'id1';

// Videos aus, werden bei send/receive eingeschaltet
document.getElementById('remoteVideo').style.display = 'none';
document.getElementById('localVideo').style.display = 'none';
document.getElementById("localStatus").style.display = "none";
document.getElementById("remoteStatus").style.display = "none";


// WebSocket verbinden
function connectWebSocket() {
  const wsProtocol = location.protocol === "https:" ? "wss" : "ws";
  ws = new WebSocket(`${wsProtocol}://${location.host}/ws`);

  ws.onopen = () => {
    console.log("[DEBUG] WebSocket connected");
    if (myRole)
      ws.send(JSON.stringify({ type: "register", role: myRole, roomId: ROOM_ID }));
    setAppState(ConnectionState.WAITING);
  };

  ws.onmessage = handleMessage;
  ws.onerror = e => console.error("[DEBUG] WebSocket Error:", e);

  ws.onclose = () => {
    console.warn("[DEBUG] WebSocket closed – try reconnect ...");
	setInfoMsg("websocket try reconnect");
    setAppState(ConnectionState.ERROR);
    setTimeout(() => {
      connectWebSocket();
      if (myRole) {
        ws.addEventListener("open", () => {
          ws.send(JSON.stringify({ type: "register", role: myRole, roomId: ROOM_ID }));
         }, { once: true });
      }
    }, reconnectInterval);
  };
}
connectWebSocket();

// --- ICE Server von Xirsys laden ---
async function fetchIceServers() {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          try {
            const res = JSON.parse(xhr.responseText);
            console.log("Xirsys ICE Servers:", res.v.iceServers);
            resolve(res.v.iceServers);
          } catch (err) { reject(err); }
        } else {
          reject(new Error("Xirsys API Error " + xhr.status));
        }
      }
    };
    xhr.open("PUT", "https://global.xirsys.net/_turn/robocam", true);
    xhr.setRequestHeader("Authorization", "Basic " + btoa("aborsro:e2d37f0c-800f-11f0-98d4-0242ac150002"));
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.send(JSON.stringify({ format: "urls" }));
  });
}


function blackoutScreen() {
  blackOut = !blackOut;
  document.getElementById('blackoutArea').style.display = blackOut ? 'block' : 'none';
  document.getElementById('blackoutBtn').textContent = blackOut ? 'display' : 'blackout';
}

async function handleMessage(msg) {
  try {
    const text = msg.data instanceof Blob ? await msg.data.text() : msg.data;
    let data;
    try { data = JSON.parse(text); } catch { return; }

    if (data.sdp) {
      if (!pc) return;
      try {
        await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
        if (data.sdp.type === 'offer') {
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({ sdp: pc.localDescription }));
        }
      } catch (err) {
        console.error("setRemoteDescription error:", err);
      }
    } else if (data.candidate) {
      if (!pc) return;
      try {
        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
      } catch (err) {
        console.error("addIceCandidate error:", err);
      }
    }
  } catch (err) {
    console.error("handleMessage error:", err);
  }
}

async function start(role) {
  document.getElementById("loginForm").style.display = "none";
  document.getElementById("changeForm").style.display = "none";

  console.log(`[DEBUG] Starte als ${role}`);
  myRole = role;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'register', role: myRole, roomId: ROOM_ID }));
  }
  const senderBtn = document.getElementById('senderBtn');
  const receiverBtn = document.getElementById('receiverBtn');
  const stopBtn = document.getElementById('stopBtn');
  document.getElementById('localVideo').srcObject = null;
  document.getElementById('remoteVideo').srcObject = null;
  senderBtn.disabled = true;
  receiverBtn.disabled = true;
  senderBtn.classList.remove('active');
  receiverBtn.classList.remove('active');
  senderBtn.textContent = "send";
  receiverBtn.textContent = "receive";

  if (role === 'sender') { 
    setInfoMsg("start sender");
	toggleAudio();
    senderBtn.classList.add('active');
    document.getElementById("localVideo").style.display = "block"; 
    document.getElementById("remoteStatus").style.display = "none";
    document.getElementById("localStatus").style.display = "block";
  }
  if (role === 'receiver') {
    setInfoMsg("start receiver");
    receiverBtn.classList.add('active');
    document.getElementById("remoteVideo").style.display = "block";
    document.getElementById("blackoutArea").style.display = "none";
    document.getElementById("localStatus").style.display = "none";
    document.getElementById("remoteStatus").style.display = "block";
  }
  stopBtn.style.display = 'block';
  setAppState(ConnectionState.WAITING);

  // --- ICE Server laden ---
  let iceServers = [];
  try {
    iceServers = await fetchIceServers();
  } catch (e) {
    console.error("ICE Server fetch failed:", e);
  }
  
  pc = new RTCPeerConnection({
    iceServers: iceServers.length ? iceServers : [{ urls: "stun:stun.l.google.com:19302" }]
  });

  // --- Transceiver nur für Receiver ---
  if (role === 'receiver') {
    console.log("[DEBUG] Receiver: adding recvonly transceivers");
    pc.addTransceiver("video", { direction: "recvonly" });
    pc.addTransceiver("audio", { direction: "recvonly" });
  }

  // --- Remote-Stream empfangen ---
  pc.ontrack = e => {
    console.log("[DEBUG] Track received:", e.streams);
    const remoteVideo = document.getElementById('remoteVideo');
    remoteVideo.srcObject = e.streams[0];
    remoteVideo.play().catch(err => console.error("Play error:", err));
    setAppState(ConnectionState.CONNECTED);
  };

  pc.onicecandidate = e => { if (e.candidate) ws.send(JSON.stringify({ candidate: e.candidate })); };
  pc.oniceconnectionstatechange = () => {
    console.log("[DEBUG] ICE state:", pc.iceConnectionState);
    if (['disconnected','failed'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.ERROR); attemptReconnectWithDelay(5);
    }
    if (['connected'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.CONNECTED);
	  setInfoMsg(" ... live");
    }
  };

  if (role === 'sender') {
    const select = document.getElementById('cameraSelect');
    select.style.display = 'block';
    await fillCameraSelect();
  }
}


// --- Kameraauswahl füllen ---
async function fillCameraSelect() {
  try {
    setInfoMsg("fillCameraSelect");
    await navigator.mediaDevices.getUserMedia({ video: true });
    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoDevices = devices.filter(d => d.kind === "videoinput");
    const select = document.getElementById("cameraSelect");
    select.innerHTML = "";

    videoDevices.forEach((device, i) => {
      const opt = document.createElement("option");
      opt.value = device.deviceId;
      opt.textContent = device.label || `Kamera ${i+1}`;
      select.appendChild(opt);
    });

    if (videoDevices.length > 0) select.style.display = "block";

    if (videoDevices.length === 1) { 
      await startLocalStreamAndOffer();
    } else {
      select.onchange = async () => { await startLocalStreamAndOffer(); };
    }
  } catch (err) {
    console.error("fillCameraSelect error:", err);
  }
}

async function startLocalStreamAndOffer() {
  try {
  	  setInfoMsg("startLocalStreamAndOffer");

    // Alte Streams schließen
    if (localStream) { 
      localStream.getTracks().forEach(track => track.stop()); 
      localStream = null; 
    }

    const select = document.getElementById('cameraSelect');
    const videoConstraints = select.value ? { deviceId: { exact: select.value } } : true;

    localStream = await navigator.mediaDevices.getUserMedia({ 
      video: videoConstraints, 
      audio: audioSetting 
    });

    // Tracks anhängen
    localStream.getTracks().forEach(track => { if (pc) pc.addTrack(track, localStream); });
    localVideo.srcObject = localStream;

    // --- NEUES Offer erzwingen ---
    if (pc) {
      console.log("[DEBUG] Creating fresh offer with all tracks");
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      ws.send(JSON.stringify({ sdp: pc.localDescription }));
      localOfferSent = true;
    }
  } catch (e) {
    console.error("startLocalStreamAndOffer error:", e);
    alert("Cam/Mic access not granted or available");
  }
}


function toggleAudio() {
  audioSetting = !audioSetting;
  if (localStream) { localStream.getAudioTracks().forEach(t => t.enabled = audioSetting); }
  document.getElementById('audioBtn').textContent = audioSetting ? 'audio on' : 'audio off';
}

function stopAll() {
  setInfoMsg("stopAll");
  setAppState(ConnectionState.IDLE);
  localOfferSent = false;
  //myRole = null;
  if (pc) { pc.close(); pc = null; }
  if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
  document.getElementById('senderBtn').disabled = false;
  document.getElementById('receiverBtn').disabled = false;
  document.getElementById('senderBtn').classList.remove('active');
  document.getElementById('receiverBtn').classList.remove('active');
  document.getElementById('stopBtn').style.display = 'none';
  document.getElementById('cameraSelect').style.display = 'none';
//  document.getElementById('localVideo').srcObject = null;
//  document.getElementById('remoteVideo').srcObject = null;
  document.getElementById('blackoutArea').style.display = 'none';
}

function attemptReconnectWithDelay(seconds) {
  setInfoMsg("try reconnect");
  setTimeout(() => {
    if (!pc || pc.iceConnectionState === 'disconnected') {
      console.log("[DEBUG] try to reconnect");
      stopAll(); if (myRole) start(myRole);
    }
  }, seconds * 1000);
}
</script>
</body>
</html>
