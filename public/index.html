<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>robocam</title>
<style>
  body { font-family: sans-serif; display: flex; flex-direction: column; padding: 20px; background: linear-gradient(to bottom, #f4f4f4, #e0e0e0); min-height: 100vh; }
  #loginForm, #changeForm { margin-bottom: 20px;}
  
  .form-row {
  display: flex;
  align-items: center;
  gap: 15px;
  margin-bottom: 10px;
}

.form-row input {
  padding: 6px 10px;
  height: 33px;
  border-radius: 8px;
  border: 1px solid #ccc;
  font-size: 14px;
}

  #app { display: none; }
  #statusDisplay { margin-top: 10px; font-weight: bold; }
  .top-bar { display: flex; align-items: left; justify-content: left; gap: 10px; flex-wrap: wrap; width: 100%; max-width: 600px; margin-bottom: 10px; }
  .buttons { display: flex; flex-wrap: wrap; gap: 8px; }
  .app-icon { width: 40px; height: 40px; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.2); }
  h1 { margin: 10px; font-size: 1.8em; color: #333; }

  button, select, #toggleSizeBtn {
  font-size: 1.0em;
  margin: 0;
  width: auto;
  max-width: none;
  border: none;
  border-radius: 10px;
  background-color: #808080;
  color: white;
  cursor: pointer;
  transition: background-color 0.3s, transform 0.1s;

  span.led {
  display: inline-block;
  width: 10px;
  height: 10px;
  margin-right: 6px;
  border-radius: 50%;
  background-color: grey;
  vertical-align: middle;
  box-shadow: 0 0 2px rgba(0,0,0,0.5);
  transition: background-color 0.2s, box-shadow 0.2s;
}

span.led.on {
  background-color: red;
  box-shadow: 0 0 5px red;
}
  
  height: 33px;
  padding: 0 16px;
  
  display: flex;
  align-items: center;
  justify-content: center;
}

  button:hover:enabled { background-color: #45a049; }
  button:disabled { cursor: not-allowed; opacity: 0.8; }
  button.active { background-color: #00FF00; transform: scale(1.05); }
  #stopBtn { background-color: #FF0000; }
  #stopBtn:hover:enabled { background-color: #d32f2f; }
  #remoteVideo { width: 70%; max-width: 100%; }
  #localVideo { width: 70%; max-width: 100%; }
  #blackoutBtn { background-color: grey; opacity: 1; z-index: 99999; }
  #audioBtn { background-color: grey; opacity: 1; z-index: 99998; }
  #blackoutArea { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: black; opacity: 1; z-index: 99998; }
  #controls { margin-bottom: 15px; }

  #toggleSizeBtn {
    padding: 10px 20px;
    background: #0077cc;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
  }

  #toggleSizeBtn:hover {
    background: #005fa3;
  }

.video-container {
  position: relative;
  width: 100%;
  max-width: 100%;
  margin: 10px 0;
  display: inline-block;
}

video {
  display: block;
  width: 100%;
  height: auto;
  background: black;
  border: 3px solid #ccc;
  border-radius: 8px;
  position: relative;
  z-index: 1;
}

.status-overlay {
  position: absolute;
  bottom: 10px;
  left: 10px;
  background: rgba(0,0,0,0.6);
  color: #fff;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 14px;
  z-index: 2;
  pointer-events: none;
}

.fullwidth {
  max-width: 100% !important;
  width: 100% !important;
  height: 100% !important;
  object-fit: contain;
}

  .inline-container img { vertical-align: middle; height: 40px; }
  .inline-container span { vertical-align: middle; margin-left: 10px; font-size: 30px; }
</style>
</head>
<body>

<div id="loginForm">
  <h2>Login for ROBOCAM</h2>
  <div class="form-row">
    <input type="password" id="password" maxlength="20" placeholder="enter password">
    <button onclick="login()">Login</button>
  </div>
  <p id="loginMsg"></p>
</div>

<div id="changeForm" style="display:none;">
  <h3>Change password (master only)</h3>
  <div class="form-row">
    <input type="password" id="newPassword" maxlength="20" placeholder="new password">
    <button onclick="changePassword()">Change</button>
  </div>
  <p id="changeMsg"></p>
</div>

<div id="app">
  <div class="inline-container">
    <img src="favicon.ico" alt="App Icon" class="app-icon">
   <span>robocam</span>v86
   <input type="text" id="infoMsg" style="margin-left: 10px;">
   <input type="text" id="infoMode" style="margin-left: 10px;">
  </div>
  <br>
  <div class="top-bar">
   <div class="buttons">
  	 	<div id="controls">
       <button id="toggleSizeBtn">?? wide</button>
    </div>
     <button id="senderBtn" onclick="start('sender')">send</button>
<button id="receiverBtn" onclick="start('receiver')">
  <span class="led"></span> receive
</button>
      <button id="stopBtn" onclick="stopAll()" style="display:none;">stop</button>
      <button id="audioBtn">audio off</button>
      <button id="blackoutBtn" onclick="blackoutScreen()">blackout</button>
      <select id="cameraSelect" style="display:none;"></select>
    </div>
    <div id="blackoutArea"></div>
  </div>
  
  <div class="video-container">
    <video id="remoteVideo" autoplay playsinline></video>
    <div id="remoteStatus" class="status-overlay">Status: idle</div>
  </div>

  <div class="video-container">
    <video id="localVideo" autoplay muted playsinline></video>
    <div id="localStatus" class="status-overlay"></div>
  </div>
</div>

<script>
const localVideo = document.getElementById("localVideo");
const remoteVideo = document.getElementById("remoteVideo");
const toggleBtn = document.getElementById("toggleSizeBtn");
let pc;
let ws;
let role;
let full = false;
let idleRestartTimer = null;
let isNegotiating = false;
let makingOffer = false;
let polite = false;
let iceCandidateQueue = []; // ? NEU: Queue für frühe ICE candidates

toggleBtn.onclick = () => {
  full = !full;
  if (full) {
    localVideo.classList.add("fullwidth");
    remoteVideo.classList.add("fullwidth");
    toggleBtn.textContent = "?? normal";
  } else {
    localVideo.classList.remove("fullwidth");
    remoteVideo.classList.remove("fullwidth");
    toggleBtn.textContent = "?? wide";
  }
};

// --- Login / Passwort-Logik ---
async function login() {
  try {
    const pw = document.getElementById("password").value;
    const res = await fetch("/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ password: pw })
    });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();

    if (data.success) {
      document.getElementById("loginForm").style.display = "none";
      if (data.message === "master") {
         document.getElementById("changeForm").style.display = "block";
      } else {
         document.getElementById("app").style.display = "block";
      }
    } else {
      document.getElementById("loginMsg").innerText = "Wrong Password!";
    }
  } catch (err) {
    console.error("Login-Fehler:", err);
    document.getElementById("loginMsg").innerText = "Serverfehler!";
  }
}

async function changePassword() {
  try {
    const newPw = document.getElementById("newPassword").value;
    const master = document.getElementById("password").value;

    const res = await fetch("/change-password", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ master: master, newPassword: newPw })
    });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const data = await res.json();
    document.getElementById("changeMsg").innerText = data.message;
    document.getElementById("loginForm").style.display = "block";
    document.getElementById("changeForm").style.display = "none";
    document.getElementById('password').value = "";
  } catch (err) {
    console.error("Passwort-Änderung Fehler:", err);
    document.getElementById("changeMsg").innerText = "Serverfehler!";
  }
}

// --- robocam Code ---
setInfoMsg("[DEBUG] Initialising ROBOCAM App");

const ConnectionState = {
  IDLE: 'idle', WAITING: 'waiting', READY: 'ready',
  CONNECTING: 'connecting', CONNECTED: 'connected', ERROR: 'error',
};
let appState = ConnectionState.IDLE;

function setInfoMsg(msg) {
  console.log(msg);
  const infoMsg = document.getElementById('infoMsg');
  if (infoMsg) infoMsg.value = `${msg}`;
}

function setAppState(state) {
  appState = state;
  setInfoMsg(`[STATE] ${state}`);

  const remoteStatus = document.getElementById('remoteStatus');
  if (remoteStatus) remoteStatus.textContent = `Status: ${state}`;

  const localStatus = document.getElementById('localStatus');
  if (localStatus) localStatus.textContent = `Status: ${state}`; 
}

let localStream;
let localOfferSent = false;
let blackOut = false;
let remoteOut = true;
let localOut = true;
let myRole = null;
let audioSetting = true;
let fillCameraSelectDone = false;

const reconnectInterval = 3000;
const ROOM_ID = 'id1';

document.getElementById('remoteVideo').style.display = 'none';
document.getElementById('localVideo').style.display = 'none';
document.getElementById("localStatus").style.display = "none";
document.getElementById("remoteStatus").style.display = "none";

const iceServers = [
  {
    urls: [
      "stun:fr-turn3.xirsys.com",
      "turn:fr-turn3.xirsys.com:80?transport=udp",
      "turn:fr-turn3.xirsys.com:3478?transport=udp",
      "turn:fr-turn3.xirsys.com:80?transport=tcp",
      "turn:fr-turn3.xirsys.com:3478?transport=tcp",
      "turns:fr-turn3.xirsys.com:443?transport=tcp",
      "turns:fr-turn3.xirsys.com:5349?transport=tcp"
    ],
    username: "h2x8QP2MzZzIqqJdIkTjOPwg2CP9JuX-3ohJnNzzkilRsL5uWXi1bZl56AeLhlfhAAAAAGkPAc1hYm9yc3Jv",
    credential: "77c9ae1a-bc7e-11f0-8996-4a5c3d748004"
  }
];

// ? OPTIMIERT: ICE-Kandidaten-Queue abarbeiten
async function processIceCandidateQueue() {
  if (!pc || !pc.remoteDescription) return;
  
  setInfoMsg(`[DEBUG] Processing ${iceCandidateQueue.length} queued ICE candidates`);
  
  while (iceCandidateQueue.length > 0) {
    const candidate = iceCandidateQueue.shift();
    try {
      await pc.addIceCandidate(new RTCIceCandidate(candidate));
    } catch (err) {
      console.error("Queued candidate error:", err);
    }
  }
}

function createPeerConnection(servers) {
  pc = new RTCPeerConnection({ iceServers: servers });

  pc.oniceconnectionstatechange = () => {
    if (!pc) return;
    setInfoMsg("[DEBUG] ICE state: " + pc.iceConnectionState);
    if (['disconnected','failed'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.ERROR);
      attemptReconnectWithDelay(5);
    }
    if (pc.iceConnectionState === 'connected') {
      setAppState(ConnectionState.CONNECTED);
    }
  };

  pc.onconnectionstatechange = () => {
    if (!pc) return;
    setInfoMsg("[DEBUG] Connection state: " + pc.connectionState);
  };

  pc.onicecandidate = e => {
    if (e.candidate && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ candidate: e.candidate }));
    }
  };

  pc.ontrack = e => {
    if (e.streams && e.streams[0]) {
      if (myRole === 'receiver') {
        remoteVideo.srcObject = e.streams[0];
        safePlay(remoteVideo);
        setInfoMsg("Receiving video/audio");
      }
    }
  };

  return pc;
}

function connectWebSocket() {
  const wsProtocol = location.protocol === "https:" ? "wss" : "ws";
  ws = new WebSocket(`${wsProtocol}://${location.host}/ws`);

  ws.onopen = () => {
    setInfoMsg("[DEBUG] WebSocket connected");
    if (myRole)
      ws.send(JSON.stringify({ type: "register", role: myRole, roomId: ROOM_ID }));
    setAppState(ConnectionState.WAITING);
  };

  ws.onmessage = handleMessage;
  ws.onerror = e => console.error("[DEBUG] WebSocket Error:", e);

  ws.onclose = () => {
    console.warn("[DEBUG] WebSocket closed – try reconnect ...");
	setInfoMsg("websocket try reconnect");
    setAppState(ConnectionState.ERROR);
    setTimeout(() => {
      connectWebSocket();
      if (myRole) {
        ws.addEventListener("open", () => {
          ws.send(JSON.stringify({ type: "register", role: myRole, roomId: ROOM_ID }));
         }, { once: true });
      }
    }, reconnectInterval);
  };
}

connectWebSocket();
audioSetting = false;
setAudioTracks(false);
audioBtn.textContent = "audio off";

function blackoutScreen() {
  blackOut = !blackOut;
  document.getElementById('blackoutArea').style.display = blackOut ? 'block' : 'none';
  document.getElementById('blackoutBtn').textContent = blackOut ? 'display' : 'blackout';
}

audioBtn.addEventListener("click", () => {
  audioSetting = !audioSetting;
  setAudioTracks(audioSetting);
  audioBtn.textContent = audioSetting ? "audio on" : "audio off";
});

function setAudioTracks(enable) {
  if (localStream) {
    localStream.getAudioTracks().forEach(track => {
      track.enabled = enable;
    });
  }
}

// ? VERBESSERT: Robustere Message-Behandlung mit ICE-Queue
async function handleMessage(msg) {
  try {
    let text;
    if (msg.data instanceof Blob) {
      text = await msg.data.text();
    } else {
      text = msg.data;
    }

    let data;
    try {
      data = JSON.parse(text);
    } catch (err) {
      console.error("JSON parse error:", err, text);
      return;
    }

    if (data.type === "error") {
      alert(data.message);
      stopAll();
      return;
    }

    if (data.type === "senderStatus") {
      const senderBtn = document.getElementById("senderBtn");
      window.senderActive = data.active;

      if (data.active) {
        senderBtn.disabled = true;
        senderBtn.textContent = "sender (locked)";
      } else {
        senderBtn.disabled = false;
        senderBtn.textContent = "send";
      }
      return;
    }

    if (!pc) return;

    // SDP handling
    if (data.sdp) {
      const description = new RTCSessionDescription(data.sdp);
      const isOffer = description.type === "offer";

      // Offer collision
      const offerCollision = isOffer && (makingOffer || pc.signalingState !== "stable");

      if (offerCollision) {
        if (!polite) {
          setInfoMsg("[DEBUG] Offer collision – ignored (impolite peer)");
          return;
        }
        setInfoMsg("[DEBUG] Offer collision – polite peer: rollback local offer");
        try {
          await pc.setLocalDescription({ type: "rollback" });
          makingOffer = false;
        } catch (rbErr) {
          console.warn("Rollback failed (might be ok):", rbErr);
        }
      }

      if (description.type === "answer") {
        if (pc.signalingState === "have-local-offer") {
          await pc.setRemoteDescription(description);
          setInfoMsg("[DEBUG] Answer accepted");
          await processIceCandidateQueue();
        } else {
          console.warn("Answer ignored – wrong signaling state:", pc.signalingState);
        }
        return;
      }

      if (description.type === "offer") {
        try {
          await pc.setRemoteDescription(description);
          await processIceCandidateQueue();
          setInfoMsg("[DEBUG] Creating answer to remote offer");
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({ sdp: pc.localDescription }));
        } catch (err) {
          console.error("Failed to handle remote offer:", err);
        }
        return;
      }
    }

    // ICE candidate handling
    if (data.candidate) {
      if (!pc.remoteDescription || !pc.remoteDescription.type) {
        setInfoMsg("[DEBUG] Queueing ICE candidate (no remote desc yet)");
        iceCandidateQueue.push(data.candidate);
        return;
      }
      try {
        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
      } catch (err) {
        console.error("addIceCandidate error:", err);
      }
    }

  } catch (err) {
    console.error("handleMessage error:", err);
  }
}


let playPromise;

function safePlay(videoEl) {
  if (playPromise) {
    playPromise.catch(() => {}).finally(() => {});
  }
  playPromise = videoEl.play();
  playPromise.catch(err => {
    if (err.name !== "AbortError") {
      console.warn("Play error:", err);
    }
  });
}

async function start(role) {
  document.getElementById("loginForm").style.display = "none";
  document.getElementById("changeForm").style.display = "none";

  setInfoMsg(`[DEBUG] Starte als ${role}`);
  myRole = role;
  polite = (role === 'receiver');
  
  // ? NEU: ICE-Queue zurücksetzen bei neuem Start
  iceCandidateQueue = [];
  
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'register', role: myRole, roomId: ROOM_ID }));
  }
  
  const senderBtn = document.getElementById('senderBtn');
  const receiverBtn = document.getElementById('receiverBtn');
  const stopBtn = document.getElementById('stopBtn');
  
  document.getElementById('localVideo').srcObject = null;
  document.getElementById('remoteVideo').srcObject = null;
  senderBtn.disabled = true;
  receiverBtn.disabled = true;
  senderBtn.classList.remove('active');
  receiverBtn.classList.remove('active');
  senderBtn.textContent = "send";
  receiverBtn.textContent = "receive";

  if (role === 'sender') { startSender(); } 
  else { startReceiver(); }
}
  
function determineConnectionType() {
  pc.addEventListener("iceconnectionstatechange", async () => {
    if (pc.iceConnectionState === "connected") {
      try {
        const stats = await pc.getStats();
        stats.forEach(report => {
          if (report.type === "candidate-pair" && report.state === "succeeded") {
            const local = stats.get(report.localCandidateId);
            const remote = stats.get(report.remoteCandidateId);
  
            if (local && remote) {
              let connectionType = "Unknown connection";
  
              if (local.candidateType === "relay" || remote.candidateType === "relay") {
                connectionType = "TURN connection active";
                console.log("? TURN server in use (relay)");
              } else if (local.candidateType === "srflx" || remote.candidateType === "srflx") {
                connectionType = "STUN connection active";
                console.log("? STUN server in use (srflx)");
              } else if (local.candidateType === "host" || remote.candidateType === "host") {
                connectionType = "Direct P2P connection";
                console.log("? Direct peer-to-peer (host)");
              }
  
              const infoField = document.getElementById("infoMode");
              if (infoField) infoField.value = connectionType;
            }
          }
        });
      } catch (err) {
        console.error("Error checking ICE candidates:", err);
      }
    }
  });
}

async function startSender() {
  setInfoMsg("start sender");
  ws.send(JSON.stringify({ type: "senderStatus", active: true, roomId: ROOM_ID }));
  ws.send(JSON.stringify({ type: "register", role: "sender", roomId: ROOM_ID }));
  senderBtn.classList.add('active');
  document.getElementById("localVideo").style.display = "block"; 
  document.getElementById("remoteVideo").style.display = "none";
  document.getElementById("remoteStatus").style.display = "none";
  document.getElementById("localStatus").style.display = "block";

  stopBtn.style.display = 'block';
  setAppState(ConnectionState.WAITING);

  pc = createPeerConnection(iceServers); 
  determineConnectionType();

  pc.onnegotiationneeded = async () => {
    try {
      makingOffer = true;
      setInfoMsg("[DEBUG] Negotiation needed – creating offer");
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      ws.send(JSON.stringify({ sdp: pc.localDescription }));
    } catch (err) {
      console.error("onnegotiationneeded error:", err);
    } finally {
      makingOffer = false;
    }
  };

  pc.onconnectionstatechange = () => {
    if (!pc) return;
    setInfoMsg("[DEBUG] Connection state: " + pc.connectionState);
    if (pc.connectionState === "connected") {
      const receivers = pc.getReceivers();
      receivers.forEach(r => {
        if (r.track && r.track.kind === "video") {
          const remoteVideo = document.getElementById("remoteVideo");
          if (remoteVideo.srcObject !== new MediaStream([r.track])) {
            console.log("Rebinding remote video track");
            remoteVideo.srcObject = new MediaStream([r.track]);
          }
        }
      });
    }
  };
 
  pc.onicecandidate = e => { 
    if (e.candidate) ws.send(JSON.stringify({ candidate: e.candidate })); 
  };
  
  pc.oniceconnectionstatechange = () => {
    if (!pc) return;
    setInfoMsg("[DEBUG] ICE state:", pc.iceConnectionState);
    if (['disconnected','failed'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.ERROR); 
      attemptReconnectWithDelay(5);
    }
    if (['connected'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.CONNECTED);
    }
  };

  // ? WICHTIG: Erst Local Stream starten, DANN Tracks hinzufügen
  const select = document.getElementById('cameraSelect');
  select.style.display = 'block';
  await startLocalStream();
  await fillCameraSelect();
  setInfoMsg("sending");
  select.onchange = async () => {
    await startLocalStreamAndOffer();
  };
}

async function startReceiver() {
  setInfoMsg("start receiver");
  receiverBtn.classList.add('active');
  const led = receiverBtn.querySelector('.led');
  if (led) led.classList.add('on');
  
  document.getElementById("remoteVideo").style.display = "block";
  document.getElementById("localVideo").style.display = "none";
  document.getElementById("blackoutArea").style.display = "none";
  document.getElementById("localStatus").style.display = "none";
  document.getElementById("remoteStatus").style.display = "block";
 
  stopBtn.style.display = 'block';
  setAppState(ConnectionState.WAITING);

  pc = createPeerConnection(iceServers); 
  determineConnectionType();

  // ? WICHTIG: ontrack MUSS vor transceivers gesetzt werden
  pc.ontrack = e => {
    setInfoMsg("[DEBUG] ontrack fired - streams:", e.streams.length);
    if (e.streams && e.streams[0]) {
      setInfoMsg("[DEBUG] Setting remote video stream");
      remoteVideo.srcObject = e.streams[0];
      safePlay(remoteVideo);
      setInfoMsg("receiving video/audio");
    }
  };

  // Dann Transceiver hinzufügen
  setInfoMsg("[DEBUG] Receiver: adding recvonly transceivers");
  pc.addTransceiver("video", { direction: "recvonly" });
  pc.addTransceiver("audio", { direction: "recvonly" });
  
  pc.onconnectionstatechange = () => {
    if (!pc) return;
    if (pc.connectionState === "connected") {
      const receivers = pc.getReceivers();
      receivers.forEach(r => {
        if (r.track && r.track.kind === "video") {
          const remoteVideo = document.getElementById("remoteVideo");
          if (remoteVideo.srcObject !== new MediaStream([r.track])) {
            console.log("Rebinding remote video track");
            remoteVideo.srcObject = new MediaStream([r.track]);
          }
        }
      });
    }
  };
 
  pc.onicecandidate = e => { if (e.candidate) ws.send(JSON.stringify({ candidate: e.candidate })); };
  pc.oniceconnectionstatechange = () => {
    setInfoMsg("[DEBUG] ICE state:", pc.iceConnectionState);
    if (['disconnected','failed'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.ERROR); 
      attemptReconnectWithDelay(5);
    }
    if (['connected'].includes(pc.iceConnectionState)) {
      setAppState(ConnectionState.CONNECTED);
    }
  };
}

let getUserMediaDone = false;

async function getLocalStreamOnce() {
  if (localStream) return localStream;
  setInfoMsg("getLocalStreamOnce: acquiring media...");
  localStream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: audioSetting
  });
  getUserMediaDone = true;
  return localStream;
}

async function fillCameraSelect() {
  try {
    if (fillCameraSelectDone) return;
    setInfoMsg("fillCameraSelect");

    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoDevices = devices.filter(d => d.kind === "videoinput");
    const select = document.getElementById("cameraSelect");
    select.innerHTML = "";

    videoDevices.forEach((device, i) => {
      const opt = document.createElement("option");
      opt.value = device.deviceId;
      opt.textContent = device.label || `Kamera ${i + 1}`;
      select.appendChild(opt);
    });

    select.onchange = async () => {
      if (!pc) return;
      setInfoMsg("switching camera...");
      await startLocalStreamAndOffer();
    };

    if (lastCameraId) select.value = lastCameraId;
    fillCameraSelectDone = true;
  } catch (err) {
    console.error("fillCameraSelect error:", err);
    alert("Device in use");
    setAppState(ConnectionState.ERROR);
    attemptReconnectWithDelay(5);
  }
}

async function startLocalStream() {
  try {
    setInfoMsg("startLocalStream");
    await getLocalStreamOnce();

    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoDevices = devices.filter(d => d.kind === "videoinput");
    const select = document.getElementById("cameraSelect");

    if (videoDevices.length > 0) select.style.display = "block";

    await startLocalStreamAndOffer();
  } catch (err) {
    console.error("startLocalStream error:", err);
    alert("Device in use");
    setAppState(ConnectionState.ERROR);
    attemptReconnectWithDelay(5);
  }
}

let lastCameraId = null;

// ? KRITISCH: startLocalStreamAndOffer muss Tracks zur PeerConnection hinzufügen
async function startLocalStreamAndOffer() {
  try {
    setInfoMsg("startLocalStreamAndOffer");

    const select = document.getElementById('cameraSelect');
    const videoConstraints = select.value ? { deviceId: { exact: select.value } } : true;

    // Prüfen ob bereits die gleiche Kamera aktiv ist
    if (localStream && localStream.active) {
      const currentVideoTrack = localStream.getVideoTracks()[0];
      if (currentVideoTrack && currentVideoTrack.getSettings().deviceId === select.value) {
        setInfoMsg("Same camera already active");
//        return;
      }
    }

    const newStream = await navigator.mediaDevices.getUserMedia({
      video: videoConstraints,
      audio: audioSetting
    });

    const newVideoTrack = newStream.getVideoTracks()[0];
    const newAudioTrack = newStream.getAudioTracks()[0];

    if (pc) {
      const senders = pc.getSenders();
      const videoSender = senders.find(s => s.track?.kind === "video");
      const audioSender = senders.find(s => s.track?.kind === "audio");

      // ? WICHTIG: Beim ersten Mal addTrack, danach replaceTrack
      if (videoSender) {
        setInfoMsg("[DEBUG] Replacing video track");
        await videoSender.replaceTrack(newVideoTrack);
      } else if (newVideoTrack) {
        setInfoMsg("[DEBUG] Adding video track to PeerConnection");
        pc.addTrack(newVideoTrack, newStream);
      }

      if (audioSender) {
        setInfoMsg("[DEBUG] Replacing audio track");
        await audioSender.replaceTrack(newAudioTrack);
      } else if (newAudioTrack) {
        setInfoMsg("[DEBUG] Adding audio track to PeerConnection");
        pc.addTrack(newAudioTrack, newStream);
      }
    }

    // Lokales Video aktualisieren
    localVideo.srcObject = newStream;
    try { 
      await localVideo.play(); 
    } catch (err) { 
      console.warn("localVideo play error:", err); 
    }

    // Alten Stream stoppen
    if (localStream && localStream !== newStream) {
      localStream.getTracks().forEach(track => track.stop());
    }
    
    localStream = newStream;
    lastCameraId = select.value;

    setInfoMsg("Camera/Audio updated - tracks added to PC");

  } catch (err) {
    console.error("startLocalStreamAndOffer error:", err);
    alert("Cam/Mic access not granted or available");
  }
}

function disableAudio() {
  setInfoMsg("disableAudio");
  audioSetting = false;
  if (localStream) { 
    localStream.getAudioTracks().forEach(t => t.enabled = false); 
  }
  document.getElementById('audioBtn').textContent = 'audio on';
}

// ? OPTIMIERT: Memory Leak Fix - alle Ressourcen sauber freigeben
function stopAll() {
  setInfoMsg("stopAll");
  setAppState(ConnectionState.IDLE);
  localOfferSent = false;
  
  // ? NEU: Video-Elemente sauber leeren
  const localVideoEl = document.getElementById('localVideo');
  const remoteVideoEl = document.getElementById('remoteVideo');
  const infoField = document.getElementById("infoMode");
  infoField.value = "";
 
  if (localVideoEl) {
    localVideoEl.pause();
    localVideoEl.srcObject = null;
  }
  
  if (remoteVideoEl) {
    remoteVideoEl.pause();
    remoteVideoEl.srcObject = null;
  }
  
  if (myRole === "sender") {
    ws.send(JSON.stringify({ type: "senderStatus", active: false, roomId: ROOM_ID }));
  }

  // ? OPTIMIERT: PeerConnection mit allen Tracks stoppen
  if (pc) {
    pc.getSenders().forEach(sender => {
      if (sender.track) sender.track.stop();
    });
    
    pc.oniceconnectionstatechange = null;
    pc.onconnectionstatechange = null;
    pc.onnegotiationneeded = null;
    pc.onicecandidate = null;
    pc.ontrack = null;
    pc.close();
    pc = null;
  }
  
  // ? OPTIMIERT: LocalStream vollständig stoppen
  if (localStream) {
    localStream.getTracks().forEach(t => {
      t.stop();
      t.enabled = false;
    });
    localStream = null;
  }
  
  // ? NEU: ICE-Queue zurücksetzen
  iceCandidateQueue = [];
  
  const senderBtn = document.getElementById('senderBtn');
  const receiverBtn = document.getElementById('receiverBtn');

  senderBtn.disabled = false;
  receiverBtn.disabled = false;
  senderBtn.classList.remove('active');
  receiverBtn.classList.remove('active');
  
  const led = receiverBtn.querySelector('.led');
  if (led) led.classList.remove('on');
  
  document.getElementById('stopBtn').style.display = 'none';
  document.getElementById('cameraSelect').style.display = 'none';
  document.getElementById('blackoutArea').style.display = 'none';

  if (window.senderActive) {
    senderBtn.disabled = true;
    senderBtn.textContent = "sender (locked)";
  }
}

function attemptReconnectWithDelay(seconds) {
  setInfoMsg("try reconnect");
  setTimeout(() => {
    if (!pc || pc.iceConnectionState === 'disconnected') {
      setInfoMsg("[DEBUG] try to reconnect");
      stopAll(); 
      if (myRole) start(myRole);
    }
  }, seconds * 1000);
}

</script>
</body>
</html>