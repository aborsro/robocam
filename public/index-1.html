<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>robocam</title>
<style>
  body { font-family: sans-serif; padding: 20px; }
  video { border: 2px solid #333; background: #000; width: 45%; }
</style>
</head>
<body>
<h1>robocam</h1>
<div>
  <button id="senderBtn">Senden</button>
  <button id="receiverBtn">Empfangen</button>
  <button id="stopBtn" hidden>Stop</button>
  <select id="cameraSelect" hidden></select>
</div>
<div id="statusDisplay">Status: idle</div>
<video id="remoteVideo" autoplay playsinline></video>
<video id="localVideo" autoplay muted playsinline></video>

<script>
const ConnectionState = {
  IDLE: 'idle',
  WAITING: 'waiting',
  CONNECTING: 'connecting',
  CONNECTED: 'connected',
  ERROR: 'error',
};
let appState = ConnectionState.IDLE;
let pc, localStream, localOfferSent = false, myRole = null, ws;

function setAppState(state) {
  appState = state;
  document.getElementById('statusDisplay').textContent = `Status: ${state}`;
}

function connectWebSocket() {
  const wsProtocol = location.protocol === 'https:' ? 'wss' : 'ws';
  ws = new WebSocket(`${wsProtocol}://${location.host}/ws`);
  ws.onopen = () => {
    console.log("WebSocket verbunden");
    if (myRole) ws.send(JSON.stringify({ type: 'register', role: myRole }));
    setAppState(ConnectionState.WAITING);
  };
  ws.onmessage = handleMessage;
  ws.onclose = () => {
    console.warn("WebSocket geschlossen â€“ reconnect ...");
    setAppState(ConnectionState.ERROR);
    setTimeout(connectWebSocket, 3000);
  };
}
connectWebSocket();

async function handleMessage(msg) {
  let data;
  try { data = JSON.parse(msg.data); } catch { return; }

  if (data.type === 'receiver-ready' && myRole === 'sender') {
    await startLocalStreamAndOffer();
    return;
  }

  if (data.sdp && pc) {
    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
    if (data.sdp.type === 'offer') {
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      ws.send(JSON.stringify({ sdp: pc.localDescription }));
    }
  } else if (data.candidate && pc) {
    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
  }
}

async function start(role) {
  myRole = role;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'register', role }));
  }
  document.getElementById('senderBtn').disabled = true;
  document.getElementById('receiverBtn').disabled = true;
  document.getElementById('stopBtn').hidden = false;
  setAppState(ConnectionState.WAITING);

  pc = new RTCPeerConnection({
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
  });

  pc.ontrack = e => {
    document.getElementById('remoteVideo').srcObject = e.streams[0];
    setAppState(ConnectionState.CONNECTED);
  };
  pc.onicecandidate = e => {
    if (e.candidate) ws.send(JSON.stringify({ candidate: e.candidate }));
  };

  if (role === 'sender') {
    await fillCameraSelect();
    document.getElementById('cameraSelect').hidden = false;
  }
}

async function fillCameraSelect() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const videoDevices = devices.filter(d => d.kind === 'videoinput');
  const select = document.getElementById('cameraSelect');
  select.innerHTML = '';
  videoDevices.forEach((device, i) => {
    const option = document.createElement('option');
    option.value = device.deviceId || '';
    option.text = device.label || `Kamera ${i+1}`;
    select.appendChild(option);
  });
  select.onchange = startLocalStreamAndOffer;
  if (videoDevices.length > 0) {
    select.value = videoDevices[0].deviceId || '';
    await startLocalStreamAndOffer();
  }
}

async function startLocalStreamAndOffer() {
  if (localOfferSent) return;
  localOfferSent = true;
  setAppState(ConnectionState.CONNECTING);

  const cameraId = document.getElementById('cameraSelect').value;
  const video = { width: { ideal: 1280 }, height: { ideal: 720 } };
  if (cameraId) video.deviceId = { exact: cameraId };

  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video, audio: true });
    document.getElementById('localVideo').srcObject = localStream;
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    ws.send(JSON.stringify({ sdp: pc.localDescription }));
    document.getElementById('cameraSelect').hidden = true;
  } catch (e) {
    console.error("Kamera/Mikrofon Fehler:", e);
    alert("Fehler beim Zugriff auf Kamera/Mikrofon.");
    setAppState(ConnectionState.ERROR);
    localOfferSent = false;
  }
}

function stopAll() {
  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
    localStream = null;
  }
  if (pc) {
    pc.close();
    pc = null;
  }
  localOfferSent = false;
  ['senderBtn', 'receiverBtn'].forEach(id => {
    const el = document.getElementById(id);
    el.disabled = false;
  });
  document.getElementById('cameraSelect').hidden = true;
  document.getElementById('stopBtn').hidden = true;
  document.getElementById('localVideo').srcObject = null;
  document.getElementById('remoteVideo').srcObject = null;
  setAppState(ConnectionState.IDLE);
}

document.getElementById('senderBtn').onclick = () => start('sender');
document.getElementById('receiverBtn').onclick = () => start('receiver');
document.getElementById('stopBtn').onclick = stopAll;
</script>
</body>
</html>
